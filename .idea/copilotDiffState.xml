<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;net.mineaqua&lt;/groupId&gt;&#10;    &lt;artifactId&gt;AFKRegions&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;AFKRegions&lt;/name&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;java.version&gt;1.8&lt;/java.version&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.8.1&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;${java.version}&lt;/source&gt;&#10;                    &lt;target&gt;${java.version}&lt;/target&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.2.4&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;relocations&gt;&#10;                        &lt;relocation&gt;&#10;                            &lt;pattern&gt;org.mariadb&lt;/pattern&gt;&#10;                            &lt;shadedPattern&gt;net.mineaqua.afkregions.libs.mariadb&lt;/shadedPattern&gt;&#10;                        &lt;/relocation&gt;&#10;                    &lt;/relocations&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;shade&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;        &lt;resources&gt;&#10;            &lt;resource&gt;&#10;                &lt;directory&gt;src/main/resources&lt;/directory&gt;&#10;                &lt;filtering&gt;true&lt;/filtering&gt;&#10;            &lt;/resource&gt;&#10;        &lt;/resources&gt;&#10;    &lt;/build&gt;&#10;&#10;    &lt;repositories&gt;&#10;        &lt;repository&gt;&#10;            &lt;id&gt;spigotmc-repo&lt;/id&gt;&#10;            &lt;url&gt;https://hub.spigotmc.org/nexus/content/repositories/snapshots/&lt;/url&gt;&#10;        &lt;/repository&gt;&#10;        &lt;repository&gt;&#10;            &lt;id&gt;sonatype&lt;/id&gt;&#10;            &lt;url&gt;https://oss.sonatype.org/content/groups/public/&lt;/url&gt;&#10;        &lt;/repository&gt;&#10;        &lt;repository&gt;&#10;            &lt;id&gt;placeholderapi&lt;/id&gt;&#10;            &lt;url&gt;https://repo.extendedclip.com/content/repositories/placeholderapi/&lt;/url&gt;&#10;        &lt;/repository&gt;&#10;    &lt;/repositories&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.spigotmc&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spigot-api&lt;/artifactId&gt;&#10;            &lt;version&gt;1.16.5-R0.1-SNAPSHOT&lt;/version&gt;&#10;            &lt;scope&gt;provided&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;me.clip&lt;/groupId&gt;&#10;            &lt;artifactId&gt;placeholderapi&lt;/artifactId&gt;&#10;            &lt;version&gt;2.11.5&lt;/version&gt;&#10;            &lt;scope&gt;provided&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;!-- MariaDB Driver --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;&#10;            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;&#10;            &lt;version&gt;2.7.9&lt;/version&gt;&#10;            &lt;scope&gt;compile&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/mineaqua/afkregions/AFKRegionsPlugin.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/mineaqua/afkregions/AFKRegionsPlugin.java" />
              <option name="originalContent" value="&#10;package net.mineaqua.afkregions;&#10;&#10;import net.mineaqua.afkregions.papi.AFKRegionsExpansion;&#10;import net.mineaqua.afkregions.region.RegionManager;&#10;import net.mineaqua.afkregions.runtime.PlayerTracker;&#10;import net.mineaqua.afkregions.util.Messages;&#10;import net.mineaqua.afkregions.version.LegacyAdapter;&#10;import net.mineaqua.afkregions.version.ModernAdapter;&#10;import net.mineaqua.afkregions.version.VersionAdapter;&#10;import net.mineaqua.afkregions.cmd.AFKRegionsCommand;&#10;import net.mineaqua.afkregions.selection.SelectionManager;&#10;import net.mineaqua.afkregions.selection.SelectionListener;&#10;import org.bukkit.plugin.PluginManager;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;&#10;public class AFKRegionsPlugin extends JavaPlugin {&#10;    private static AFKRegionsPlugin instance;&#10;&#10;    private Messages messages;&#10;&#10;    private RegionManager regionManager;&#10;&#10;    private SelectionManager selections;&#10;    private VersionAdapter adapter;&#10;&#10;    private PlayerTracker tracker;&#10;&#10;    public static AFKRegionsPlugin get() {&#10;        return instance;&#10;    }&#10;&#10;    public Messages messages() {&#10;        return messages;&#10;    }&#10;&#10;    public RegionManager regions() {&#10;        return regionManager;&#10;    }&#10;&#10;    public PlayerTracker tracker() {&#10;        return tracker;&#10;    }&#10;&#10;    public VersionAdapter adapter() {&#10;        return adapter;&#10;    }&#10;&#10;    public SelectionManager selections() {&#10;        return selections;&#10;    }&#10;&#10;    @Override&#10;    public void onEnable() {&#10;        instance = this;&#10;&#10;        saveDefaultConfig();&#10;        saveResource(&quot;lang.yml&quot;, false);&#10;        saveResource(&quot;regions.yml&quot;, false);&#10;&#10;        this.adapter = hasClass(&quot;org.bukkit.boss.BossBar&quot;) ? new ModernAdapter(this) : new LegacyAdapter(this);&#10;&#10;        this.messages = new Messages(this);&#10;        this.messages.reload();&#10;&#10;        this.tracker = new PlayerTracker(this);&#10;&#10;        this.regionManager = new RegionManager(this);&#10;        this.selections = new SelectionManager();&#10;&#10;        PluginManager pluginManager = getServer().getPluginManager();&#10;        pluginManager.registerEvents(new SelectionListener(selections), this);&#10;&#10;        AFKRegionsCommand cmd = new AFKRegionsCommand(this);&#10;        getCommand(&quot;afkregions&quot;).setExecutor(cmd);&#10;        getCommand(&quot;afkregions&quot;).setTabCompleter(cmd);&#10;&#10;        if (pluginManager.isPluginEnabled(&quot;PlaceholderAPI&quot;)) {&#10;            new AFKRegionsExpansion(this).register();&#10;            getLogger().info(&quot;PlaceholderAPI detected — registering placeholders.&quot;);&#10;        }&#10;&#10;        tracker.start();&#10;        getLogger().info(&quot;AFKRegions enabled.&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        if (tracker != null) {&#10;            tracker.stop();&#10;        }&#10;&#10;        if (adapter != null) {&#10;            adapter.shutdown();&#10;        }&#10;    }&#10;&#10;    public void reloadAll() {&#10;        reloadConfig();&#10;&#10;        messages.reload();&#10;        regionManager.reload();&#10;&#10;        tracker.reloadSettings();&#10;    }&#10;&#10;    private boolean hasClass(String className) {&#10;        try {&#10;            Class.forName(className);&#10;            return true;&#10;        } catch (ClassNotFoundException e) {&#10;            return false;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package net.mineaqua.afkregions;&#13;&#10;&#13;&#10;import net.mineaqua.afkregions.database.DatabaseManager;&#13;&#10;import net.mineaqua.afkregions.database.StatisticsManager;&#13;&#10;import net.mineaqua.afkregions.papi.AFKRegionsExpansion;&#13;&#10;import net.mineaqua.afkregions.region.RegionManager;&#13;&#10;import net.mineaqua.afkregions.runtime.PlayerTracker;&#13;&#10;import net.mineaqua.afkregions.util.Messages;&#13;&#10;import net.mineaqua.afkregions.version.LegacyAdapter;&#13;&#10;import net.mineaqua.afkregions.version.ModernAdapter;&#13;&#10;import net.mineaqua.afkregions.version.VersionAdapter;&#13;&#10;import net.mineaqua.afkregions.cmd.AFKRegionsCommand;&#13;&#10;import net.mineaqua.afkregions.selection.SelectionManager;&#13;&#10;import net.mineaqua.afkregions.selection.SelectionListener;&#13;&#10;import org.bukkit.plugin.PluginManager;&#13;&#10;import org.bukkit.plugin.java.JavaPlugin;&#13;&#10;&#13;&#10;public class AFKRegionsPlugin extends JavaPlugin {&#13;&#10;    private static AFKRegionsPlugin instance;&#13;&#10;&#13;&#10;    private Messages messages;&#13;&#10;    private RegionManager regionManager;&#13;&#10;    private SelectionManager selections;&#13;&#10;    private VersionAdapter adapter;&#13;&#10;    private PlayerTracker tracker;&#13;&#10;    private DatabaseManager databaseManager;&#13;&#10;    private StatisticsManager statisticsManager;&#13;&#10;&#13;&#10;    public static AFKRegionsPlugin get() {&#13;&#10;        return instance;&#13;&#10;    }&#13;&#10;&#13;&#10;    public Messages messages() {&#13;&#10;        return messages;&#13;&#10;    }&#13;&#10;&#13;&#10;    public RegionManager regions() {&#13;&#10;        return regionManager;&#13;&#10;    }&#13;&#10;&#13;&#10;    public PlayerTracker tracker() {&#13;&#10;        return tracker;&#13;&#10;    }&#13;&#10;&#13;&#10;    public VersionAdapter adapter() {&#13;&#10;        return adapter;&#13;&#10;    }&#13;&#10;&#13;&#10;    public SelectionManager selections() {&#13;&#10;        return selections;&#13;&#10;    }&#13;&#10;&#13;&#10;    public DatabaseManager database() {&#13;&#10;        return databaseManager;&#13;&#10;    }&#13;&#10;&#13;&#10;    public StatisticsManager statistics() {&#13;&#10;        return statisticsManager;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void onEnable() {&#13;&#10;        instance = this;&#13;&#10;&#13;&#10;        saveDefaultConfig();&#13;&#10;        saveResource(&quot;lang.yml&quot;, false);&#13;&#10;        saveResource(&quot;regions.yml&quot;, false);&#13;&#10;&#13;&#10;        this.adapter = hasClass(&quot;org.bukkit.boss.BossBar&quot;) ? new ModernAdapter(this) : new LegacyAdapter(this);&#13;&#10;&#13;&#10;        this.messages = new Messages(this);&#13;&#10;        this.messages.reload();&#13;&#10;&#13;&#10;        // Inicializar sistema de base de datos&#13;&#10;        this.databaseManager = new DatabaseManager(this);&#13;&#10;&#13;&#10;        // Inicializar sistema de estadísticas&#13;&#10;        this.statisticsManager = new StatisticsManager(this, databaseManager);&#13;&#10;&#13;&#10;        this.tracker = new PlayerTracker(this);&#13;&#10;&#13;&#10;        this.regionManager = new RegionManager(this);&#13;&#10;        this.selections = new SelectionManager();&#13;&#10;&#13;&#10;        PluginManager pluginManager = getServer().getPluginManager();&#13;&#10;        pluginManager.registerEvents(new SelectionListener(selections), this);&#13;&#10;&#13;&#10;        AFKRegionsCommand cmd = new AFKRegionsCommand(this);&#13;&#10;        getCommand(&quot;afkregions&quot;).setExecutor(cmd);&#13;&#10;        getCommand(&quot;afkregions&quot;).setTabCompleter(cmd);&#13;&#10;&#13;&#10;        if (pluginManager.isPluginEnabled(&quot;PlaceholderAPI&quot;)) {&#13;&#10;            new AFKRegionsExpansion(this).register();&#13;&#10;            getLogger().info(&quot;PlaceholderAPI detected — registering placeholders.&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        tracker.start();&#13;&#10;        getLogger().info(&quot;AFKRegions enabled.&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void onDisable() {&#13;&#10;        if (statisticsManager != null) {&#13;&#10;            statisticsManager.shutdown();&#13;&#10;        }&#13;&#10;&#13;&#10;        if (tracker != null) {&#13;&#10;            tracker.stop();&#13;&#10;        }&#13;&#10;&#13;&#10;        if (databaseManager != null) {&#13;&#10;            databaseManager.close();&#13;&#10;        }&#13;&#10;&#13;&#10;        if (adapter != null) {&#13;&#10;            adapter.shutdown();&#13;&#10;        }&#13;&#10;&#13;&#10;        getLogger().info(&quot;AFKRegions disabled.&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    public void reloadAll() {&#13;&#10;        reloadConfig();&#13;&#10;&#13;&#10;        messages.reload();&#13;&#10;        regionManager.reload();&#13;&#10;        &#13;&#10;        if (statisticsManager != null) {&#13;&#10;            statisticsManager.reloadConfig();&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (tracker != null) {&#13;&#10;            tracker.reloadSettings();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private boolean hasClass(String className) {&#13;&#10;        try {&#13;&#10;            Class.forName(className);&#13;&#10;            return true;&#13;&#10;        } catch (ClassNotFoundException e) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/mineaqua/afkregions/cmd/AFKRegionsCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/mineaqua/afkregions/cmd/AFKRegionsCommand.java" />
              <option name="originalContent" value="package net.mineaqua.afkregions.cmd;&#10;&#10;import net.mineaqua.afkregions.AFKRegionsPlugin;&#10;import net.mineaqua.afkregions.model.Region;&#10;import net.mineaqua.afkregions.model.RegionReward;&#10;import net.mineaqua.afkregions.selection.SelectionListener;&#10;import net.mineaqua.afkregions.selection.SelectionManager;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.command.TabCompleter;&#10;import org.bukkit.entity.Player;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Collection;&#10;import java.util.List;&#10;import java.util.Locale;&#10;import java.util.function.BiPredicate;&#10;&#10;public class AFKRegionsCommand implements CommandExecutor, TabCompleter {&#10;    private final AFKRegionsPlugin plugin;&#10;&#10;    public AFKRegionsCommand(AFKRegionsPlugin plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {&#10;        if (args.length == 0 || args[0].equalsIgnoreCase(&quot;help&quot;)) {&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_wand&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_create&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_reward_list&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_reward_add&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_reward_remove&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_reload&quot;));&#10;&#10;            return true;&#10;        }&#10;&#10;        if (!sender.hasPermission(&quot;afkregions.admin&quot;)) {&#10;            sender.sendMessage(plugin.messages().msg(&quot;no_perm&quot;));&#10;            return true;&#10;        }&#10;&#10;        String sub = args[0].toLowerCase(java.util.Locale.ROOT);&#10;&#10;        // ── wand ─────────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;wand&quot;)) {&#10;            if (!(sender instanceof Player)) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;wand_only_players&quot;));&#10;                return true;&#10;            }&#10;            Player p = (Player) sender;&#10;            p.getInventory().addItem(SelectionListener.makeWand());&#10;            p.sendMessage(plugin.messages().msg(&quot;wand_given&quot;));&#10;            return true;&#10;        }&#10;&#10;        // ── create ───────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;create&quot;)) {&#10;            if (!(sender instanceof Player) || args.length &lt; 3) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;invalid_args&quot;));&#10;                return true;&#10;            }&#10;            Player p = (Player) sender;&#10;            String name = args[1];&#10;            int dur = parseInt(args[2], 600);&#10;&#10;            SelectionManager.Selection selection = plugin.selections().peek(p.getUniqueId());&#10;            if (selection == null || selection.position1() == null || selection.position2() == null) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;selection_needed&quot;).replace(&quot;{label}&quot;, label));&#10;                return true;&#10;            }&#10;            if (!selection.position1().getWorld().equals(selection.position2().getWorld()) || !selection.position1().getWorld().equals(p.getWorld())) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;selection_world_mismatch&quot;));&#10;                return true;&#10;            }&#10;&#10;            Region r = new Region(&#10;                    name,&#10;                    p.getWorld().getName(),&#10;                    selection.position1().getBlockX(), selection.position1().getBlockY(), selection.position1().getBlockZ(),&#10;                    selection.position2().getBlockX(), selection.position2().getBlockY(), selection.position2().getBlockZ(),&#10;                    dur,&#10;                    new java.util.ArrayList&lt;&gt;() // lista mutable&#10;            );&#10;            plugin.regions().add(r);&#10;            sender.sendMessage(plugin.messages().msg(&quot;created_region&quot;).replace(&quot;{region}&quot;, name));&#10;            plugin.selections().clear(p.getUniqueId());&#10;            return true;&#10;        }&#10;&#10;        // ── reward &lt;list|add|remove&gt; ─────────────────────────────────────────&#10;        if (sub.equals(&quot;reward&quot;)) {&#10;            if (args.length &lt; 2) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;reward_usage_main&quot;));&#10;                return true;&#10;            }&#10;            String action = args[1].toLowerCase(java.util.Locale.ROOT);&#10;&#10;            // list&#10;            if (action.equals(&quot;list&quot;)) {&#10;                if (args.length &lt; 3) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;reward_list_usage&quot;));&#10;                    return true;&#10;                }&#10;                String regionName = args[2];&#10;                Region r = plugin.regions().get(regionName);&#10;                if (r == null) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;region_not_found&quot;).replace(&quot;{region}&quot;, regionName));&#10;                    return true;&#10;                }&#10;&#10;                java.util.List&lt;RegionReward&gt; L = r.rewards();&#10;                if (L == null || L.isEmpty()) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;reward_list_empty&quot;).replace(&quot;{region}&quot;, r.name()));&#10;                    return true;&#10;                }&#10;                sender.sendMessage(plugin.messages().msg(&quot;rewards_header&quot;).replace(&quot;{region}&quot;, r.name()));&#10;                for (int i = 0; i &lt; L.size(); i++) {&#10;                    RegionReward rr = L.get(i);&#10;                    String when = rr.always() ? &quot;always&quot; : (rr.atSeconds() + &quot;s&quot;);&#10;                    int chancePct = (int) Math.round(rr.chance() * 100.0);&#10;                    sender.sendMessage(plugin.messages().msg(&quot;rewards_item&quot;)&#10;                            .replace(&quot;{index}&quot;, String.valueOf(i + 1))&#10;                            .replace(&quot;{at}&quot;, when)&#10;                            .replace(&quot;{chance}&quot;, String.valueOf(chancePct))&#10;                            .replace(&quot;{command}&quot;, rr.command()));&#10;                }&#10;                return true;&#10;            }&#10;&#10;            // add&#10;            if (action.equals(&quot;add&quot;)) {&#10;                if (args.length &lt; 6) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;reward_add_usage&quot;));&#10;                    return true;&#10;                }&#10;                String regionName = args[2];&#10;                Region r = plugin.regions().get(regionName);&#10;                if (r == null) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;region_not_found&quot;).replace(&quot;{region}&quot;, regionName));&#10;                    return true;&#10;                }&#10;&#10;                // porcentaje%&#10;                String percentTok = args[3];&#10;                if (!percentTok.endsWith(&quot;%&quot;)) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;percentage_end_percent&quot;));&#10;                    return true;&#10;                }&#10;                double chance;&#10;                try {&#10;                    chance = Math.max(0, Math.min(1, Double.parseDouble(percentTok.substring(0, percentTok.length() - 1)) / 100.0));&#10;                } catch (Exception ex) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;percentage_invalid&quot;));&#10;                    return true;&#10;                }&#10;&#10;                // tiempo en segundos: 10s&#10;                String timeTok = args[4].toLowerCase(java.util.Locale.ROOT);&#10;                if (!timeTok.endsWith(&quot;s&quot;)) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;time_end_s&quot;));&#10;                    return true;&#10;                }&#10;                int at;&#10;                try {&#10;                    at = Integer.parseInt(timeTok.substring(0, timeTok.length() - 1));&#10;                } catch (Exception ex) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;time_invalid&quot;));&#10;                    return true;&#10;                }&#10;                if (at &lt; 0) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;time_must_be_ge_zero&quot;));&#10;                    return true;&#10;                }&#10;&#10;                // comando&#10;                String command = join(args, 5);&#10;&#10;                r.rewards().add(new RegionReward(false, at, chance, command));&#10;                plugin.regions().persist(r);&#10;                plugin.tracker().refreshRegionRef(r.name());&#10;&#10;                sender.sendMessage(plugin.messages().msg(&quot;added_reward&quot;)&#10;                        .replace(&quot;{region}&quot;, r.name())&#10;                        .replace(&quot;{spec}&quot;, &quot;at=&quot; + at + &quot;s, chance=&quot; + (int) Math.round(chance * 100) + &quot;%, cmd=&quot; + command));&#10;                return true;&#10;            }&#10;&#10;            // remove&#10;            if (action.equals(&quot;remove&quot;)) {&#10;                if (args.length &lt; 4) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;reward_remove_usage&quot;));&#10;                    return true;&#10;                }&#10;                String regionName = args[2];&#10;                Region r = plugin.regions().get(regionName);&#10;                if (r == null) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;region_not_found&quot;).replace(&quot;{region}&quot;, regionName));&#10;                    return true;&#10;                }&#10;&#10;                int index1;&#10;                try {&#10;                    index1 = Integer.parseInt(args[3]);&#10;                } catch (Exception e) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;index_invalid&quot;));&#10;                    return true;&#10;                }&#10;                int idx = index1 - 1;&#10;                if (idx &lt; 0 || idx &gt;= r.rewards().size()) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;index_oob&quot;).replace(&quot;{region}&quot;, r.name()));&#10;                    return true;&#10;                }&#10;&#10;                RegionReward removed = r.rewards().remove(idx);&#10;                plugin.regions().persist(r);&#10;                plugin.tracker().refreshRegionRef(r.name());&#10;&#10;                String when = removed.always() ? &quot;always&quot; : (removed.atSeconds() + &quot;s&quot;);&#10;                int chancePct = (int) Math.round(removed.chance() * 100.0);&#10;                sender.sendMessage(plugin.messages().msg(&quot;removed_reward&quot;)&#10;                        .replace(&quot;{index}&quot;, String.valueOf(index1))&#10;                        .replace(&quot;{at}&quot;, when)&#10;                        .replace(&quot;{chance}&quot;, String.valueOf(chancePct)));&#10;                return true;&#10;            }&#10;&#10;            sender.sendMessage(plugin.messages().msg(&quot;subcommand_invalid&quot;));&#10;            return true;&#10;        }&#10;&#10;        // ── list ─────────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;list&quot;)) {&#10;            Collection&lt;Region&gt; all = plugin.regions().all();&#10;            sender.sendMessage(plugin.messages().raw(&quot;list_header&quot;).replace(&quot;{count}&quot;, String.valueOf(all.size())));&#10;            for (Region r : all) {&#10;                sender.sendMessage(plugin.messages().raw(&quot;list_item&quot;)&#10;                        .replace(&quot;{name}&quot;, r.name())&#10;                        .replace(&quot;{world}&quot;, r.world())&#10;                        .replace(&quot;{min}&quot;, r.minX() + &quot;,&quot; + r.minY() + &quot;,&quot; + r.minZ())&#10;                        .replace(&quot;{max}&quot;, r.maxX() + &quot;,&quot; + r.maxY() + &quot;,&quot; + r.maxZ())&#10;                        .replace(&quot;{duration}&quot;, String.valueOf(r.durationSeconds()))&#10;                        .replace(&quot;{rewards}&quot;, String.valueOf(r.rewards().size())));&#10;            }&#10;            return true;&#10;        }&#10;&#10;        // ── remove ───────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;remove&quot;)) {&#10;            if (args.length &lt; 2) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;invalid_args&quot;));&#10;                return true;&#10;            }&#10;            String name = args[1];&#10;            boolean ok = plugin.regions().remove(name);&#10;            sender.sendMessage(ok&#10;                    ? plugin.messages().msg(&quot;removed_region&quot;).replace(&quot;{region}&quot;, name)&#10;                    : plugin.messages().msg(&quot;region_not_found&quot;).replace(&quot;{region}&quot;, name));&#10;            return true;&#10;        }&#10;&#10;        // ── reload ───────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;reload&quot;)) {&#10;            plugin.reloadAll();&#10;            sender.sendMessage(plugin.messages().msg(&quot;reloaded&quot;));&#10;            return true;&#10;        }&#10;&#10;        sender.sendMessage(plugin.messages().msg(&quot;invalid_args&quot;));&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;String&gt; onTabComplete(CommandSender sender, Command cmd, String label, String[] args) {&#10;        List&lt;String&gt; out = new ArrayList&lt;&gt;();&#10;        if (!sender.hasPermission(&quot;afkregions.admin&quot;)) return out;&#10;&#10;        BiPredicate&lt;String, String&gt; starts = (opt, pref) -&gt;&#10;                pref == null || pref.isEmpty() || opt.toLowerCase(Locale.ROOT).startsWith(pref.toLowerCase(Locale.ROOT));&#10;&#10;        if (args.length == 1) {&#10;            String p = args[0];&#10;            for (String o : new String[]{&quot;wand&quot;, &quot;create&quot;, &quot;reward&quot;, &quot;reload&quot;, &quot;remove&quot;, &quot;list&quot;})&#10;                if (starts.test(o, p)) out.add(o);&#10;            return out;&#10;        }&#10;&#10;        // /afkregions reward ...&#10;        if (args.length &gt;= 2 &amp;&amp; args[0].equalsIgnoreCase(&quot;reward&quot;)) {&#10;            if (args.length == 2) {&#10;                String p = args[1];&#10;                for (String o : new String[]{&quot;list&quot;, &quot;add&quot;, &quot;remove&quot;}) if (starts.test(o, p)) out.add(o);&#10;                return out;&#10;            }&#10;&#10;            if (args.length == 3 &amp;&amp; args[1].equalsIgnoreCase(&quot;list&quot;)) {&#10;                String p = args[2];&#10;                for (Region r : plugin.regions().all())&#10;                    if (starts.test(r.name(), p)) out.add(r.name());&#10;                return out;&#10;            }&#10;&#10;            if (args[1].equalsIgnoreCase(&quot;add&quot;)) {&#10;                if (args.length == 3) {&#10;                    String p = args[2];&#10;                    for (Region r : plugin.regions().all())&#10;                        if (starts.test(r.name(), p)) out.add(r.name());&#10;                    return out;&#10;                }&#10;                if (args.length == 4) {&#10;                    String p = args[3];&#10;                    for (String o : new String[]{&quot;100%&quot;, &quot;75%&quot;, &quot;50%&quot;, &quot;25%&quot;, &quot;10%&quot;})&#10;                        if (starts.test(o, p)) out.add(o);&#10;                    return out;&#10;                }&#10;                if (args.length == 5) {&#10;                    String p = args[4];&#10;                    for (String o : new String[]{&quot;10s&quot;, &quot;30s&quot;, &quot;60s&quot;, &quot;300s&quot;})&#10;                        if (starts.test(o, p)) out.add(o);&#10;                    return out;&#10;                }&#10;                if (args.length &gt;= 6) {&#10;                    String p = args[5];&#10;                    for (String o : new String[]{&quot;bc&quot;, &quot;broadcast&quot;, &quot;say&quot;, &quot;give&quot;, &quot;lp&quot;, &quot;eco&quot;})&#10;                        if (starts.test(o, p)) out.add(o);&#10;                    return out;&#10;                }&#10;            }&#10;&#10;            if (args[1].equalsIgnoreCase(&quot;remove&quot;)) {&#10;                if (args.length == 3) {&#10;                    String p = args[2];&#10;                    for (Region r : plugin.regions().all())&#10;                        if (starts.test(r.name(), p)) out.add(r.name());&#10;                    return out;&#10;                }&#10;                if (args.length == 4) {&#10;                    String regionName = args[2];&#10;                    Region r = plugin.regions().get(regionName);&#10;                    if (r != null &amp;&amp; r.rewards() != null &amp;&amp; !r.rewards().isEmpty()) {&#10;                        String p = args[3];&#10;                        for (int i = 1; i &lt;= r.rewards().size(); i++) {&#10;                            String idx = String.valueOf(i);&#10;                            if (starts.test(idx, p)) out.add(idx);&#10;                        }&#10;                    }&#10;                    return out;&#10;                }&#10;            }&#10;            return out;&#10;        }&#10;&#10;        return out;&#10;    }&#10;&#10;    private int parseInt(String rawNumber, int def) {&#10;        try {&#10;            return Integer.parseInt(rawNumber);&#10;        } catch (Exception e) {&#10;            return def;&#10;        }&#10;    }&#10;&#10;    private String join(String[] array, int from) {&#10;        StringBuilder builder = new StringBuilder();&#10;&#10;        for (int i = from; i &lt; array.length; i++) {&#10;            if (i &gt; from) {&#10;                builder.append(' ');&#10;            }&#10;&#10;            builder.append(array[i]);&#10;        }&#10;&#10;        return builder.toString();&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package net.mineaqua.afkregions.cmd;&#10;&#10;import net.mineaqua.afkregions.AFKRegionsPlugin;&#10;import net.mineaqua.afkregions.model.Region;&#10;import net.mineaqua.afkregions.model.RegionReward;&#10;import net.mineaqua.afkregions.selection.SelectionListener;&#10;import net.mineaqua.afkregions.selection.SelectionManager;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.command.TabCompleter;&#10;import org.bukkit.entity.Player;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Collection;&#10;import java.util.List;&#10;import java.util.Locale;&#10;import java.util.function.BiPredicate;&#10;&#10;public class AFKRegionsCommand implements CommandExecutor, TabCompleter {&#10;    private final AFKRegionsPlugin plugin;&#10;&#10;    public AFKRegionsCommand(AFKRegionsPlugin plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {&#10;        if (args.length == 0 || args[0].equalsIgnoreCase(&quot;help&quot;)) {&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_wand&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_create&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_reward_list&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_reward_add&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_reward_remove&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_reload&quot;));&#10;            sender.sendMessage(plugin.messages().msg(&quot;help_stats&quot;));&#10;&#10;            return true;&#10;        }&#10;&#10;        if (!sender.hasPermission(&quot;afkregions.admin&quot;)) {&#10;            sender.sendMessage(plugin.messages().msg(&quot;no_perm&quot;));&#10;            return true;&#10;        }&#10;&#10;        String sub = args[0].toLowerCase(java.util.Locale.ROOT);&#10;&#10;        // ── stats ────────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;stats&quot;)) {&#10;            if (!plugin.statistics().isEnabled()) {&#10;                sender.sendMessage(&quot;§cStatistics system is disabled.&quot;);&#10;                return true;&#10;            }&#10;            &#10;            if (args.length &lt; 2) {&#10;                sender.sendMessage(&quot;§6=== AFK Statistics ===&quot;);&#10;                sender.sendMessage(&quot;§e/afkregions stats &lt;player&gt; §7- View player's AFK time&quot;);&#10;                sender.sendMessage(&quot;§e/afkregions stats save §7- Force save all statistics&quot;);&#10;                sender.sendMessage(&quot;§e/afkregions stats info §7- Show system information&quot;);&#10;                return true;&#10;            }&#10;            &#10;            String action = args[1].toLowerCase();&#10;            &#10;            if (action.equals(&quot;save&quot;)) {&#10;                plugin.statistics().saveAllStats();&#10;                sender.sendMessage(&quot;§aForced save of all statistics initiated.&quot;);&#10;                return true;&#10;            }&#10;            &#10;            if (action.equals(&quot;info&quot;)) {&#10;                sender.sendMessage(&quot;§6=== Statistics System Info ===&quot;);&#10;                sender.sendMessage(&quot;§eSystem enabled: §a&quot; + plugin.statistics().isEnabled());&#10;                sender.sendMessage(&quot;§eDatabase enabled: §a&quot; + plugin.database().isEnabled());&#10;                sender.sendMessage(&quot;§eCached players: §a&quot; + plugin.statistics().getCachedPlayersCount());&#10;                sender.sendMessage(&quot;§eDatabase connection: §a&quot; + plugin.database().isConnectionValid());&#10;                return true;&#10;            }&#10;            &#10;            // Ver estadísticas de un jugador específico&#10;            String playerName = args[1];&#10;            Player target = plugin.getServer().getPlayer(playerName);&#10;            &#10;            if (target == null) {&#10;                sender.sendMessage(&quot;§cPlayer not found or not online.&quot;);&#10;                return true;&#10;            }&#10;            &#10;            long totalSeconds = plugin.statistics().getTotalAFKSeconds(target.getUniqueId());&#10;            String formattedTime = formatTime(totalSeconds);&#10;            &#10;            sender.sendMessage(&quot;§6=== AFK Statistics for &quot; + target.getName() + &quot; ===&quot;);&#10;            sender.sendMessage(&quot;§eTotal AFK time: §a&quot; + formattedTime);&#10;            sender.sendMessage(&quot;§eCurrently AFK: §a&quot; + (plugin.tracker().isAfk(target.getUniqueId()) ? &quot;Yes&quot; : &quot;No&quot;));&#10;            &#10;            if (plugin.tracker().isAfk(target.getUniqueId())) {&#10;                sender.sendMessage(&quot;§eCurrent region: §a&quot; + plugin.tracker().regionName(target.getUniqueId()));&#10;                sender.sendMessage(&quot;§eTime in current session: §a&quot; + formatTime(plugin.tracker().elapsedSeconds(target.getUniqueId())));&#10;            }&#10;            &#10;            return true;&#10;        }&#10;&#10;        // ── wand ─────────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;wand&quot;)) {&#10;            if (!(sender instanceof Player)) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;wand_only_players&quot;));&#10;                return true;&#10;            }&#10;            Player p = (Player) sender;&#10;            p.getInventory().addItem(SelectionListener.makeWand());&#10;            p.sendMessage(plugin.messages().msg(&quot;wand_given&quot;));&#10;            return true;&#10;        }&#10;&#10;        // ── create ───────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;create&quot;)) {&#10;            if (!(sender instanceof Player) || args.length &lt; 3) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;invalid_args&quot;));&#10;                return true;&#10;            }&#10;            Player p = (Player) sender;&#10;            String name = args[1];&#10;            int dur = parseInt(args[2], 600);&#10;&#10;            SelectionManager.Selection selection = plugin.selections().peek(p.getUniqueId());&#10;            if (selection == null || selection.position1() == null || selection.position2() == null) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;selection_needed&quot;).replace(&quot;{label}&quot;, label));&#10;                return true;&#10;            }&#10;            if (!selection.position1().getWorld().equals(selection.position2().getWorld()) || !selection.position1().getWorld().equals(p.getWorld())) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;selection_world_mismatch&quot;));&#10;                return true;&#10;            }&#10;&#10;            Region r = new Region(&#10;                    name,&#10;                    p.getWorld().getName(),&#10;                    selection.position1().getBlockX(), selection.position1().getBlockY(), selection.position1().getBlockZ(),&#10;                    selection.position2().getBlockX(), selection.position2().getBlockY(), selection.position2().getBlockZ(),&#10;                    dur,&#10;                    new java.util.ArrayList&lt;&gt;() // lista mutable&#10;            );&#10;            plugin.regions().add(r);&#10;            sender.sendMessage(plugin.messages().msg(&quot;created_region&quot;).replace(&quot;{region}&quot;, name));&#10;            plugin.selections().clear(p.getUniqueId());&#10;            return true;&#10;        }&#10;&#10;        // ── reward &lt;list|add|remove&gt; ─────────────────────────────────────────&#10;        if (sub.equals(&quot;reward&quot;)) {&#10;            if (args.length &lt; 2) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;reward_usage_main&quot;));&#10;                return true;&#10;            }&#10;            String action = args[1].toLowerCase(java.util.Locale.ROOT);&#10;&#10;            // list&#10;            if (action.equals(&quot;list&quot;)) {&#10;                if (args.length &lt; 3) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;reward_list_usage&quot;));&#10;                    return true;&#10;                }&#10;                String regionName = args[2];&#10;                Region r = plugin.regions().get(regionName);&#10;                if (r == null) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;region_not_found&quot;).replace(&quot;{region}&quot;, regionName));&#10;                    return true;&#10;                }&#10;&#10;                java.util.List&lt;RegionReward&gt; L = r.rewards();&#10;                if (L == null || L.isEmpty()) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;reward_list_empty&quot;).replace(&quot;{region}&quot;, r.name()));&#10;                    return true;&#10;                }&#10;                sender.sendMessage(plugin.messages().msg(&quot;rewards_header&quot;).replace(&quot;{region}&quot;, r.name()));&#10;                for (int i = 0; i &lt; L.size(); i++) {&#10;                    RegionReward rr = L.get(i);&#10;                    String when = rr.always() ? &quot;always&quot; : (rr.atSeconds() + &quot;s&quot;);&#10;                    int chancePct = (int) Math.round(rr.chance() * 100.0);&#10;                    sender.sendMessage(plugin.messages().msg(&quot;rewards_item&quot;)&#10;                            .replace(&quot;{index}&quot;, String.valueOf(i + 1))&#10;                            .replace(&quot;{at}&quot;, when)&#10;                            .replace(&quot;{chance}&quot;, String.valueOf(chancePct))&#10;                            .replace(&quot;{command}&quot;, rr.command()));&#10;                }&#10;                return true;&#10;            }&#10;&#10;            // add&#10;            if (action.equals(&quot;add&quot;)) {&#10;                if (args.length &lt; 6) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;reward_add_usage&quot;));&#10;                    return true;&#10;                }&#10;                String regionName = args[2];&#10;                Region r = plugin.regions().get(regionName);&#10;                if (r == null) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;region_not_found&quot;).replace(&quot;{region}&quot;, regionName));&#10;                    return true;&#10;                }&#10;&#10;                // porcentaje%&#10;                String percentTok = args[3];&#10;                if (!percentTok.endsWith(&quot;%&quot;)) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;percentage_end_percent&quot;));&#10;                    return true;&#10;                }&#10;                double chance;&#10;                try {&#10;                    chance = Math.max(0, Math.min(1, Double.parseDouble(percentTok.substring(0, percentTok.length() - 1)) / 100.0));&#10;                } catch (Exception ex) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;percentage_invalid&quot;));&#10;                    return true;&#10;                }&#10;&#10;                // tiempo en segundos: 10s&#10;                String timeTok = args[4].toLowerCase(java.util.Locale.ROOT);&#10;                if (!timeTok.endsWith(&quot;s&quot;)) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;time_end_s&quot;));&#10;                    return true;&#10;                }&#10;                int at;&#10;                try {&#10;                    at = Integer.parseInt(timeTok.substring(0, timeTok.length() - 1));&#10;                } catch (Exception ex) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;time_invalid&quot;));&#10;                    return true;&#10;                }&#10;                if (at &lt; 0) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;time_must_be_ge_zero&quot;));&#10;                    return true;&#10;                }&#10;&#10;                // comando&#10;                String command = join(args, 5);&#10;&#10;                r.rewards().add(new RegionReward(false, at, chance, command));&#10;                plugin.regions().persist(r);&#10;                plugin.tracker().refreshRegionRef(r.name());&#10;&#10;                sender.sendMessage(plugin.messages().msg(&quot;added_reward&quot;)&#10;                        .replace(&quot;{region}&quot;, r.name())&#10;                        .replace(&quot;{spec}&quot;, &quot;at=&quot; + at + &quot;s, chance=&quot; + (int) Math.round(chance * 100) + &quot;%, cmd=&quot; + command));&#10;                return true;&#10;            }&#10;&#10;            // remove&#10;            if (action.equals(&quot;remove&quot;)) {&#10;                if (args.length &lt; 4) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;reward_remove_usage&quot;));&#10;                    return true;&#10;                }&#10;                String regionName = args[2];&#10;                Region r = plugin.regions().get(regionName);&#10;                if (r == null) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;region_not_found&quot;).replace(&quot;{region}&quot;, regionName));&#10;                    return true;&#10;                }&#10;&#10;                int index1;&#10;                try {&#10;                    index1 = Integer.parseInt(args[3]);&#10;                } catch (Exception e) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;index_invalid&quot;));&#10;                    return true;&#10;                }&#10;                int idx = index1 - 1;&#10;                if (idx &lt; 0 || idx &gt;= r.rewards().size()) {&#10;                    sender.sendMessage(plugin.messages().msg(&quot;index_oob&quot;).replace(&quot;{region}&quot;, r.name()));&#10;                    return true;&#10;                }&#10;&#10;                RegionReward removed = r.rewards().remove(idx);&#10;                plugin.regions().persist(r);&#10;                plugin.tracker().refreshRegionRef(r.name());&#10;&#10;                String when = removed.always() ? &quot;always&quot; : (removed.atSeconds() + &quot;s&quot;);&#10;                int chancePct = (int) Math.round(removed.chance() * 100.0);&#10;                sender.sendMessage(plugin.messages().msg(&quot;removed_reward&quot;)&#10;                        .replace(&quot;{index}&quot;, String.valueOf(index1))&#10;                        .replace(&quot;{at}&quot;, when)&#10;                        .replace(&quot;{chance}&quot;, String.valueOf(chancePct)));&#10;                return true;&#10;            }&#10;&#10;            sender.sendMessage(plugin.messages().msg(&quot;subcommand_invalid&quot;));&#10;            return true;&#10;        }&#10;&#10;        // ── list ─────────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;list&quot;)) {&#10;            Collection&lt;Region&gt; all = plugin.regions().all();&#10;            sender.sendMessage(plugin.messages().raw(&quot;list_header&quot;).replace(&quot;{count}&quot;, String.valueOf(all.size())));&#10;            for (Region r : all) {&#10;                sender.sendMessage(plugin.messages().raw(&quot;list_item&quot;)&#10;                        .replace(&quot;{name}&quot;, r.name())&#10;                        .replace(&quot;{world}&quot;, r.world())&#10;                        .replace(&quot;{min}&quot;, r.minX() + &quot;,&quot; + r.minY() + &quot;,&quot; + r.minZ())&#10;                        .replace(&quot;{max}&quot;, r.maxX() + &quot;,&quot; + r.maxY() + &quot;,&quot; + r.maxZ())&#10;                        .replace(&quot;{duration}&quot;, String.valueOf(r.durationSeconds()))&#10;                        .replace(&quot;{rewards}&quot;, String.valueOf(r.rewards().size())));&#10;            }&#10;            return true;&#10;        }&#10;&#10;        // ── remove ───────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;remove&quot;)) {&#10;            if (args.length &lt; 2) {&#10;                sender.sendMessage(plugin.messages().msg(&quot;invalid_args&quot;));&#10;                return true;&#10;            }&#10;            String name = args[1];&#10;            boolean ok = plugin.regions().remove(name);&#10;            sender.sendMessage(ok&#10;                    ? plugin.messages().msg(&quot;removed_region&quot;).replace(&quot;{region}&quot;, name)&#10;                    : plugin.messages().msg(&quot;region_not_found&quot;).replace(&quot;{region}&quot;, name));&#10;            return true;&#10;        }&#10;&#10;        // ── reload ───────────────────────────────────────────────────────────&#10;        if (sub.equals(&quot;reload&quot;)) {&#10;            plugin.reloadAll();&#10;            sender.sendMessage(plugin.messages().msg(&quot;reloaded&quot;));&#10;            return true;&#10;        }&#10;&#10;        sender.sendMessage(plugin.messages().msg(&quot;invalid_args&quot;));&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;String&gt; onTabComplete(CommandSender sender, Command cmd, String label, String[] args) {&#10;        List&lt;String&gt; out = new ArrayList&lt;&gt;();&#10;        if (!sender.hasPermission(&quot;afkregions.admin&quot;)) return out;&#10;&#10;        BiPredicate&lt;String, String&gt; starts = (opt, pref) -&gt;&#10;                pref == null || pref.isEmpty() || opt.toLowerCase(Locale.ROOT).startsWith(pref.toLowerCase(Locale.ROOT));&#10;&#10;        if (args.length == 1) {&#10;            String p = args[0];&#10;            for (String o : new String[]{&quot;wand&quot;, &quot;create&quot;, &quot;reward&quot;, &quot;reload&quot;, &quot;remove&quot;, &quot;list&quot;, &quot;stats&quot;})&#10;                if (starts.test(o, p)) out.add(o);&#10;            return out;&#10;        }&#10;&#10;        // /afkregions stats ...&#10;        if (args.length &gt;= 2 &amp;&amp; args[0].equalsIgnoreCase(&quot;stats&quot;)) {&#10;            if (args.length == 2) {&#10;                String p = args[1];&#10;                // Agregar opciones de estadísticas&#10;                for (String o : new String[]{&quot;save&quot;, &quot;info&quot;}) {&#10;                    if (starts.test(o, p)) out.add(o);&#10;                }&#10;                // Agregar jugadores online&#10;                for (Player player : plugin.getServer().getOnlinePlayers()) {&#10;                    if (starts.test(player.getName(), p)) out.add(player.getName());&#10;                }&#10;                return out;&#10;            }&#10;        }&#10;&#10;        // /afkregions reward ...&#10;        if (args.length &gt;= 2 &amp;&amp; args[0].equalsIgnoreCase(&quot;reward&quot;)) {&#10;            if (args.length == 2) {&#10;                String p = args[1];&#10;                for (String o : new String[]{&quot;list&quot;, &quot;add&quot;, &quot;remove&quot;}) if (starts.test(o, p)) out.add(o);&#10;                return out;&#10;            }&#10;&#10;            if (args.length == 3 &amp;&amp; args[1].equalsIgnoreCase(&quot;list&quot;)) {&#10;                String p = args[2];&#10;                for (Region r : plugin.regions().all())&#10;                    if (starts.test(r.name(), p)) out.add(r.name());&#10;                return out;&#10;            }&#10;&#10;            if (args[1].equalsIgnoreCase(&quot;add&quot;)) {&#10;                if (args.length == 3) {&#10;                    String p = args[2];&#10;                    for (Region r : plugin.regions().all())&#10;                        if (starts.test(r.name(), p)) out.add(r.name());&#10;                    return out;&#10;                }&#10;                if (args.length == 4) {&#10;                    String p = args[3];&#10;                    for (String o : new String[]{&quot;100%&quot;, &quot;75%&quot;, &quot;50%&quot;, &quot;25%&quot;, &quot;10%&quot;})&#10;                        if (starts.test(o, p)) out.add(o);&#10;                    return out;&#10;                }&#10;                if (args.length == 5) {&#10;                    String p = args[4];&#10;                    for (String o : new String[]{&quot;10s&quot;, &quot;30s&quot;, &quot;60s&quot;, &quot;300s&quot;})&#10;                        if (starts.test(o, p)) out.add(o);&#10;                    return out;&#10;                }&#10;                if (args.length &gt;= 6) {&#10;                    String p = args[5];&#10;                    for (String o : new String[]{&quot;bc&quot;, &quot;broadcast&quot;, &quot;say&quot;, &quot;give&quot;, &quot;lp&quot;, &quot;eco&quot;})&#10;                        if (starts.test(o, p)) out.add(o);&#10;                    return out;&#10;                }&#10;            }&#10;&#10;            if (args[1].equalsIgnoreCase(&quot;remove&quot;)) {&#10;                if (args.length == 3) {&#10;                    String p = args[2];&#10;                    for (Region r : plugin.regions().all())&#10;                        if (starts.test(r.name(), p)) out.add(r.name());&#10;                    return out;&#10;                }&#10;                if (args.length == 4) {&#10;                    String regionName = args[2];&#10;                    Region r = plugin.regions().get(regionName);&#10;                    if (r != null &amp;&amp; r.rewards() != null &amp;&amp; !r.rewards().isEmpty()) {&#10;                        String p = args[3];&#10;                        for (int i = 1; i &lt;= r.rewards().size(); i++) {&#10;                            String idx = String.valueOf(i);&#10;                            if (starts.test(idx, p)) out.add(idx);&#10;                        }&#10;                    }&#10;                    return out;&#10;                }&#10;            }&#10;            return out;&#10;        }&#10;&#10;        return out;&#10;    }&#10;&#10;    private int parseInt(String rawNumber, int def) {&#10;        try {&#10;            return Integer.parseInt(rawNumber);&#10;        } catch (Exception e) {&#10;            return def;&#10;        }&#10;    }&#10;&#10;    private String join(String[] array, int from) {&#10;        StringBuilder builder = new StringBuilder();&#10;&#10;        for (int i = from; i &lt; array.length; i++) {&#10;            if (i &gt; from) {&#10;                builder.append(' ');&#10;            }&#10;&#10;            builder.append(array[i]);&#10;        }&#10;&#10;        return builder.toString();&#10;    }&#10;&#10;    private String formatTime(long totalSeconds) {&#10;        long hours = totalSeconds / 3600;&#10;        long minutes = (totalSeconds % 3600) / 60;&#10;        long seconds = totalSeconds % 60;&#10;&#10;        return String.format(&quot;%02dh %02dm %02ds&quot;, hours, minutes, seconds);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/mineaqua/afkregions/database/DatabaseManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/mineaqua/afkregions/database/DatabaseManager.java" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package net.mineaqua.afkregions.database;&#10;&#10;import net.mineaqua.afkregions.AFKRegionsPlugin;&#10;import org.bukkit.configuration.ConfigurationSection;&#10;&#10;import java.sql.Connection;&#10;import java.sql.DriverManager;&#10;import java.sql.PreparedStatement;&#10;import java.sql.ResultSet;&#10;import java.sql.SQLException;&#10;import java.sql.Statement;&#10;import java.util.UUID;&#10;import java.util.concurrent.CompletableFuture;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class DatabaseManager {&#10;    private final AFKRegionsPlugin plugin;&#10;    private final ExecutorService executor;&#10;    private Connection connection;&#10;    private boolean enabled;&#10;&#10;    // Configuración de la base de datos&#10;    private String host;&#10;    private int port;&#10;    private String database;&#10;    private String username;&#10;    private String password;&#10;    private boolean useSSL;&#10;&#10;    public DatabaseManager(AFKRegionsPlugin plugin) {&#10;        this.plugin = plugin;&#10;        this.executor = Executors.newSingleThreadExecutor(r -&gt; {&#10;            Thread t = new Thread(r, &quot;AFKRegions-Database&quot;);&#10;            t.setDaemon(true);&#10;            return t;&#10;        });&#10;&#10;        loadConfig();&#10;&#10;        if (enabled) {&#10;            initializeDatabase();&#10;        }&#10;    }&#10;&#10;    private void loadConfig() {&#10;        ConfigurationSection dbConfig = plugin.getConfig().getConfigurationSection(&quot;database&quot;);&#10;        if (dbConfig == null) {&#10;            this.enabled = false;&#10;            plugin.getLogger().info(&quot;Database disabled - no configuration found.&quot;);&#10;            return;&#10;        }&#10;&#10;        this.enabled = dbConfig.getBoolean(&quot;enabled&quot;, false);&#10;        this.host = dbConfig.getString(&quot;host&quot;, &quot;localhost&quot;);&#10;        this.port = dbConfig.getInt(&quot;port&quot;, 3306);&#10;        this.database = dbConfig.getString(&quot;database&quot;, &quot;afkregions&quot;);&#10;        this.username = dbConfig.getString(&quot;username&quot;, &quot;root&quot;);&#10;        this.password = dbConfig.getString(&quot;password&quot;, &quot;&quot;);&#10;        this.useSSL = dbConfig.getBoolean(&quot;use_ssl&quot;, false);&#10;&#10;        if (!enabled) {&#10;            plugin.getLogger().info(&quot;Database disabled in configuration.&quot;);&#10;        }&#10;    }&#10;&#10;    private void initializeDatabase() {&#10;        executor.submit(() -&gt; {&#10;            try {&#10;                // Cargar el driver de MariaDB&#10;                Class.forName(&quot;org.mariadb.jdbc.Driver&quot;);&#10;&#10;                String url = String.format(&quot;jdbc:mariadb://%s:%d/%s?useSSL=%s&amp;autoReconnect=true&quot;,&#10;                        host, port, database, useSSL);&#10;&#10;                this.connection = DriverManager.getConnection(url, username, password);&#10;&#10;                // Crear la tabla si no existe&#10;                createTables();&#10;&#10;                plugin.getLogger().info(&quot;Database connection established successfully.&quot;);&#10;&#10;            } catch (ClassNotFoundException e) {&#10;                plugin.getLogger().severe(&quot;MariaDB driver not found! Please add MariaDB connector to your plugins folder.&quot;);&#10;                this.enabled = false;&#10;            } catch (SQLException e) {&#10;                plugin.getLogger().severe(&quot;Failed to connect to database: &quot; + e.getMessage());&#10;                this.enabled = false;&#10;            }&#10;        });&#10;    }&#10;&#10;    private void createTables() throws SQLException {&#10;        String createTableSQL = &quot;CREATE TABLE IF NOT EXISTS afk_statistics (&quot; +&#10;                &quot;uuid VARCHAR(36) PRIMARY KEY, &quot; +&#10;                &quot;player_name VARCHAR(16) NOT NULL, &quot; +&#10;                &quot;total_afk_seconds BIGINT NOT NULL DEFAULT 0, &quot; +&#10;                &quot;last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, &quot; +&#10;                &quot;INDEX idx_player_name (player_name), &quot; +&#10;                &quot;INDEX idx_total_seconds (total_afk_seconds)&quot; +&#10;                &quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci&quot;;&#10;&#10;        try (Statement stmt = connection.createStatement()) {&#10;            stmt.execute(createTableSQL);&#10;        }&#10;    }&#10;&#10;    public boolean isEnabled() {&#10;        return enabled;&#10;    }&#10;&#10;    public CompletableFuture&lt;Long&gt; getPlayerAFKSeconds(UUID playerId) {&#10;        if (!enabled) {&#10;            return CompletableFuture.completedFuture(0L);&#10;        }&#10;&#10;        return CompletableFuture.supplyAsync(() -&gt; {&#10;            String query = &quot;SELECT total_afk_seconds FROM afk_statistics WHERE uuid = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = connection.prepareStatement(query)) {&#10;                stmt.setString(1, playerId.toString());&#10;&#10;                try (ResultSet rs = stmt.executeQuery()) {&#10;                    if (rs.next()) {&#10;                        return rs.getLong(&quot;total_afk_seconds&quot;);&#10;                    }&#10;                }&#10;            } catch (SQLException e) {&#10;                plugin.getLogger().warning(&quot;Failed to fetch AFK seconds for player &quot; + playerId + &quot;: &quot; + e.getMessage());&#10;            }&#10;&#10;            return 0L;&#10;        }, executor);&#10;    }&#10;&#10;    public CompletableFuture&lt;Void&gt; savePlayerAFKSeconds(UUID playerId, String playerName, long totalSeconds) {&#10;        if (!enabled) {&#10;            return CompletableFuture.completedFuture(null);&#10;        }&#10;&#10;        return CompletableFuture.runAsync(() -&gt; {&#10;            String query = &quot;INSERT INTO afk_statistics (uuid, player_name, total_afk_seconds) &quot; +&#10;                    &quot;VALUES (?, ?, ?) &quot; +&#10;                    &quot;ON DUPLICATE KEY UPDATE &quot; +&#10;                    &quot;player_name = VALUES(player_name), &quot; +&#10;                    &quot;total_afk_seconds = VALUES(total_afk_seconds)&quot;;&#10;&#10;            try (PreparedStatement stmt = connection.prepareStatement(query)) {&#10;                stmt.setString(1, playerId.toString());&#10;                stmt.setString(2, playerName);&#10;                stmt.setLong(3, totalSeconds);&#10;&#10;                stmt.executeUpdate();&#10;&#10;            } catch (SQLException e) {&#10;                plugin.getLogger().warning(&quot;Failed to save AFK seconds for player &quot; + playerId + &quot;: &quot; + e.getMessage());&#10;            }&#10;        }, executor);&#10;    }&#10;&#10;    public CompletableFuture&lt;Void&gt; addPlayerAFKSeconds(UUID playerId, String playerName, long secondsToAdd) {&#10;        if (!enabled || secondsToAdd &lt;= 0) {&#10;            return CompletableFuture.completedFuture(null);&#10;        }&#10;&#10;        return CompletableFuture.runAsync(() -&gt; {&#10;            String query = &quot;INSERT INTO afk_statistics (uuid, player_name, total_afk_seconds) &quot; +&#10;                    &quot;VALUES (?, ?, ?) &quot; +&#10;                    &quot;ON DUPLICATE KEY UPDATE &quot; +&#10;                    &quot;player_name = VALUES(player_name), &quot; +&#10;                    &quot;total_afk_seconds = total_afk_seconds + VALUES(total_afk_seconds)&quot;;&#10;&#10;            try (PreparedStatement stmt = connection.prepareStatement(query)) {&#10;                stmt.setString(1, playerId.toString());&#10;                stmt.setString(2, playerName);&#10;                stmt.setLong(3, secondsToAdd);&#10;&#10;                stmt.executeUpdate();&#10;&#10;            } catch (SQLException e) {&#10;                plugin.getLogger().warning(&quot;Failed to add AFK seconds for player &quot; + playerId + &quot;: &quot; + e.getMessage());&#10;            }&#10;        }, executor);&#10;    }&#10;&#10;    public void close() {&#10;        if (enabled &amp;&amp; connection != null) {&#10;            try {&#10;                connection.close();&#10;                plugin.getLogger().info(&quot;Database connection closed.&quot;);&#10;            } catch (SQLException e) {&#10;                plugin.getLogger().warning(&quot;Failed to close database connection: &quot; + e.getMessage());&#10;            }&#10;        }&#10;&#10;        executor.shutdown();&#10;    }&#10;&#10;    public boolean isConnectionValid() {&#10;        if (!enabled || connection == null) {&#10;            return false;&#10;        }&#10;&#10;        try {&#10;            return connection.isValid(5);&#10;        } catch (SQLException e) {&#10;            return false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/mineaqua/afkregions/database/StatisticsManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/mineaqua/afkregions/database/StatisticsManager.java" />
              <option name="updatedContent" value="package net.mineaqua.afkregions.database;&#10;&#10;import net.mineaqua.afkregions.AFKRegionsPlugin;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.player.PlayerJoinEvent;&#10;import org.bukkit.event.player.PlayerQuitEvent;&#10;import org.bukkit.scheduler.BukkitRunnable;&#10;&#10;import java.util.Map;&#10;import java.util.UUID;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;public class StatisticsManager implements Listener {&#10;    private final AFKRegionsPlugin plugin;&#10;    private final DatabaseManager databaseManager;&#10;    &#10;    // Cache de estadísticas en memoria&#10;    private final Map&lt;UUID, PlayerStatistics&gt; playerStats = new ConcurrentHashMap&lt;&gt;();&#10;    &#10;    // Configuración&#10;    private boolean enabled;&#10;    private int saveIntervalMinutes;&#10;    private int autoSaveTaskId = -1;&#10;    &#10;    public StatisticsManager(AFKRegionsPlugin plugin, DatabaseManager databaseManager) {&#10;        this.plugin = plugin;&#10;        this.databaseManager = databaseManager;&#10;        &#10;        loadConfig();&#10;        &#10;        if (enabled) {&#10;            plugin.getServer().getPluginManager().registerEvents(this, plugin);&#10;            startAutoSaveTask();&#10;            plugin.getLogger().info(&quot;Statistics system enabled.&quot;);&#10;        } else {&#10;            plugin.getLogger().info(&quot;Statistics system disabled.&quot;);&#10;        }&#10;    }&#10;    &#10;    private void loadConfig() {&#10;        this.enabled = plugin.getConfig().getBoolean(&quot;statistics.enabled&quot;, true);&#10;        this.saveIntervalMinutes = Math.max(1, plugin.getConfig().getInt(&quot;statistics.auto_save_interval_minutes&quot;, 5));&#10;    }&#10;    &#10;    public void reloadConfig() {&#10;        loadConfig();&#10;        &#10;        if (enabled &amp;&amp; autoSaveTaskId == -1) {&#10;            startAutoSaveTask();&#10;        } else if (!enabled &amp;&amp; autoSaveTaskId != -1) {&#10;            stopAutoSaveTask();&#10;        }&#10;    }&#10;    &#10;    private void startAutoSaveTask() {&#10;        if (autoSaveTaskId != -1) return;&#10;        &#10;        autoSaveTaskId = new BukkitRunnable() {&#10;            @Override&#10;            public void run() {&#10;                saveAllDirtyStats();&#10;            }&#10;        }.runTaskTimerAsynchronously(plugin, saveIntervalMinutes * 20L * 60L, saveIntervalMinutes * 20L * 60L).getTaskId();&#10;    }&#10;    &#10;    private void stopAutoSaveTask() {&#10;        if (autoSaveTaskId != -1) {&#10;            plugin.getServer().getScheduler().cancelTask(autoSaveTaskId);&#10;            autoSaveTaskId = -1;&#10;        }&#10;    }&#10;    &#10;    @EventHandler&#10;    public void onPlayerJoin(PlayerJoinEvent event) {&#10;        if (!enabled) return;&#10;        &#10;        Player player = event.getPlayer();&#10;        UUID playerId = player.getUniqueId();&#10;        &#10;        // Cargar estadísticas desde la base de datos&#10;        if (databaseManager.isEnabled()) {&#10;            databaseManager.getPlayerAFKSeconds(playerId).thenAccept(totalSeconds -&gt; {&#10;                PlayerStatistics stats = new PlayerStatistics(playerId, player.getName(), totalSeconds);&#10;                playerStats.put(playerId, stats);&#10;            });&#10;        } else {&#10;            // Si la base de datos está deshabilitada, crear estadísticas vacías&#10;            PlayerStatistics stats = new PlayerStatistics(playerId, player.getName(), 0L);&#10;            playerStats.put(playerId, stats);&#10;        }&#10;    }&#10;    &#10;    @EventHandler&#10;    public void onPlayerQuit(PlayerQuitEvent event) {&#10;        if (!enabled) return;&#10;        &#10;        UUID playerId = event.getPlayer().getUniqueId();&#10;        PlayerStatistics stats = playerStats.get(playerId);&#10;        &#10;        if (stats != null &amp;&amp; stats.isDirty()) {&#10;            // Guardar estadísticas antes de que el jugador se desconecte&#10;            savePlayerStats(stats);&#10;        }&#10;        &#10;        // Remover del cache después de un pequeño delay para asegurar que se guarde&#10;        plugin.getServer().getScheduler().runTaskLaterAsynchronously(plugin, () -&gt; {&#10;            playerStats.remove(playerId);&#10;        }, 20L); // 1 segundo de delay&#10;    }&#10;    &#10;    public void addAFKTime(UUID playerId, String playerName, long secondsToAdd) {&#10;        if (!enabled || secondsToAdd &lt;= 0) return;&#10;        &#10;        PlayerStatistics stats = playerStats.get(playerId);&#10;        if (stats == null) {&#10;            // Crear estadísticas si no existen&#10;            stats = new PlayerStatistics(playerId, playerName, 0L);&#10;            playerStats.put(playerId, stats);&#10;        }&#10;        &#10;        stats.addAFKSeconds(secondsToAdd);&#10;        stats.updatePlayerName(playerName); // Actualizar el nombre en caso de que haya cambiado&#10;    }&#10;    &#10;    public long getTotalAFKSeconds(UUID playerId) {&#10;        if (!enabled) return 0L;&#10;        &#10;        PlayerStatistics stats = playerStats.get(playerId);&#10;        return stats != null ? stats.getTotalAFKSeconds() : 0L;&#10;    }&#10;    &#10;    public void savePlayerStats(UUID playerId) {&#10;        if (!enabled) return;&#10;        &#10;        PlayerStatistics stats = playerStats.get(playerId);&#10;        if (stats != null &amp;&amp; stats.isDirty()) {&#10;            savePlayerStats(stats);&#10;        }&#10;    }&#10;    &#10;    private void savePlayerStats(PlayerStatistics stats) {&#10;        if (databaseManager.isEnabled()) {&#10;            databaseManager.savePlayerAFKSeconds(&#10;                stats.getPlayerId(), &#10;                stats.getPlayerName(), &#10;                stats.getTotalAFKSeconds()&#10;            ).thenRun(() -&gt; {&#10;                stats.markAsSaved();&#10;            });&#10;        } else {&#10;            // Si la base de datos está deshabilitada, solo marcar como guardado&#10;            stats.markAsSaved();&#10;        }&#10;    }&#10;    &#10;    public void saveAllStats() {&#10;        if (!enabled) return;&#10;        &#10;        for (PlayerStatistics stats : playerStats.values()) {&#10;            if (stats.isDirty()) {&#10;                savePlayerStats(stats);&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void saveAllDirtyStats() {&#10;        if (!enabled) return;&#10;        &#10;        int savedCount = 0;&#10;        for (PlayerStatistics stats : playerStats.values()) {&#10;            if (stats.isDirty()) {&#10;                savePlayerStats(stats);&#10;                savedCount++;&#10;            }&#10;        }&#10;        &#10;        if (savedCount &gt; 0) {&#10;            plugin.getLogger().info(&quot;Auto-saved statistics for &quot; + savedCount + &quot; players.&quot;);&#10;        }&#10;    }&#10;    &#10;    public void shutdown() {&#10;        stopAutoSaveTask();&#10;        &#10;        if (enabled) {&#10;            // Guardar todas las estadísticas antes de cerrar&#10;            saveAllStats();&#10;            &#10;            // Esperar un poco para que se completen las operaciones asíncronas&#10;            try {&#10;                Thread.sleep(1000);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;            &#10;            playerStats.clear();&#10;        }&#10;    }&#10;    &#10;    public boolean isEnabled() {&#10;        return enabled;&#10;    }&#10;    &#10;    public int getCachedPlayersCount() {&#10;        return playerStats.size();&#10;    }&#10;    &#10;    // Clase interna para representar las estadísticas de un jugador&#10;    private static class PlayerStatistics {&#10;        private final UUID playerId;&#10;        private String playerName;&#10;        private long totalAFKSeconds;&#10;        private boolean dirty; // Indica si las estadísticas han cambiado y necesitan guardarse&#10;        &#10;        public PlayerStatistics(UUID playerId, String playerName, long totalAFKSeconds) {&#10;            this.playerId = playerId;&#10;            this.playerName = playerName;&#10;            this.totalAFKSeconds = totalAFKSeconds;&#10;            this.dirty = false;&#10;        }&#10;        &#10;        public void addAFKSeconds(long seconds) {&#10;            this.totalAFKSeconds += seconds;&#10;            this.dirty = true;&#10;        }&#10;        &#10;        public void updatePlayerName(String newName) {&#10;            if (!this.playerName.equals(newName)) {&#10;                this.playerName = newName;&#10;                this.dirty = true;&#10;            }&#10;        }&#10;        &#10;        public void markAsSaved() {&#10;            this.dirty = false;&#10;        }&#10;        &#10;        public UUID getPlayerId() {&#10;            return playerId;&#10;        }&#10;        &#10;        public String getPlayerName() {&#10;            return playerName;&#10;        }&#10;        &#10;        public long getTotalAFKSeconds() {&#10;            return totalAFKSeconds;&#10;        }&#10;        &#10;        public boolean isDirty() {&#10;            return dirty;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/net/mineaqua/afkregions/runtime/PlayerTracker.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/net/mineaqua/afkregions/runtime/PlayerTracker.java" />
              <option name="originalContent" value="package net.mineaqua.afkregions.runtime;&#10;&#10;import me.clip.placeholderapi.PlaceholderAPI;&#10;import net.mineaqua.afkregions.AFKRegionsPlugin;&#10;import net.mineaqua.afkregions.model.Region;&#10;import net.mineaqua.afkregions.model.RegionReward;&#10;import net.mineaqua.afkregions.version.VersionAdapter;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.Location;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.scheduler.BukkitRunnable;&#10;&#10;import java.util.HashMap;&#10;import java.util.HashSet;&#10;import java.util.LinkedHashSet;&#10;import java.util.Map;&#10;import java.util.Objects;&#10;import java.util.Set;&#10;import java.util.UUID;&#10;&#10;public class PlayerTracker {&#10;    private final Map&lt;UUID, State&gt; states = new HashMap&lt;&gt;();&#10;    private final AFKRegionsPlugin plugin;&#10;    private final VersionAdapter adapter;&#10;&#10;    private int tickInterval;&#10;    private int regionCheckInterval; // Nueva variable para el intervalo de verificación de regiones&#10;    private int rewardTaskId = -1;&#10;    private int regionCheckTaskId = -1; // Nueva tarea para verificar regiones&#10;&#10;    private boolean resetOnExit;&#10;    private boolean debug;&#10;    private boolean rewardMsgEnabled;&#10;&#10;    private void debug(String text) {&#10;        if (debug) plugin.getLogger().info(&quot;[DEBUG] &quot; + text);&#10;    }&#10;&#10;    public PlayerTracker(AFKRegionsPlugin plugin) {&#10;        this.plugin = plugin;&#10;        this.adapter = plugin.adapter();&#10;&#10;        reloadSettings();&#10;&#10;        this.debug = plugin.getConfig().getBoolean(&quot;settings.debug&quot;, false);&#10;    }&#10;&#10;    public void reloadSettings() {&#10;        this.tickInterval = Math.max(1, plugin.getConfig().getInt(&quot;settings.tick_interval&quot;, 20));&#10;        // Nuevo: intervalo para verificar regiones (por defecto cada 10 ticks = 0.5 segundos)&#10;        this.regionCheckInterval = Math.max(1, plugin.getConfig().getInt(&quot;settings.region_check_interval&quot;, 10));&#10;        this.resetOnExit = plugin.getConfig().getBoolean(&quot;settings.reset_on_exit&quot;, true);&#10;        this.rewardMsgEnabled = plugin.getConfig().getBoolean(&quot;settings.reward_message_enabled&quot;, true);&#10;    }&#10;&#10;    public void start() {&#10;        if (rewardTaskId != -1 || regionCheckTaskId != -1) return;&#10;&#10;        // Tarea para manejar recompensas y progreso&#10;        rewardTaskId = new BukkitRunnable() {&#10;            @Override&#10;            public void run() {&#10;                tickRewards();&#10;            }&#10;        }.runTaskTimer(plugin, tickInterval, tickInterval).getTaskId();&#10;&#10;        // Nueva tarea optimizada para verificar regiones&#10;        regionCheckTaskId = new BukkitRunnable() {&#10;            @Override&#10;            public void run() {&#10;                checkPlayerRegions();&#10;            }&#10;        }.runTaskTimer(plugin, regionCheckInterval, regionCheckInterval).getTaskId();&#10;    }&#10;&#10;    public void stop() {&#10;        if (rewardTaskId != -1) {&#10;            Bukkit.getScheduler().cancelTask(rewardTaskId);&#10;            rewardTaskId = -1;&#10;        }&#10;&#10;        if (regionCheckTaskId != -1) {&#10;            Bukkit.getScheduler().cancelTask(regionCheckTaskId);&#10;            regionCheckTaskId = -1;&#10;        }&#10;&#10;        for (State state : states.values()) {&#10;            adapter.clearUI(state.player());&#10;        }&#10;        states.clear();&#10;    }&#10;&#10;    // Nueva función optimizada para verificar regiones de todos los jugadores&#10;    private void checkPlayerRegions() {&#10;        for (Player player : Bukkit.getOnlinePlayers()) {&#10;            if (!player.isOnline()) continue;&#10;&#10;            Location location = player.getLocation();&#10;            int blockX = location.getBlockX();&#10;            int blockY = location.getBlockY();&#10;            int blockZ = location.getBlockZ();&#10;            String world = location.getWorld().getName();&#10;&#10;            Region currentRegion = findRegionAt(world, blockX, blockY, blockZ);&#10;&#10;            State state = states.computeIfAbsent(player.getUniqueId(), k -&gt; new State(player));&#10;            Region previousRegion = state.region();&#10;&#10;            if (!Objects.equals(previousRegion, currentRegion)) {&#10;                handleRegionChange(player, state, previousRegion, currentRegion);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Función optimizada para encontrar una región en una posición específica&#10;    private Region findRegionAt(String world, int blockX, int blockY, int blockZ) {&#10;        for (Region region : plugin.regions().candidates(world, blockX, blockZ)) {&#10;            if (region.contains(world, blockX, blockY, blockZ)) {&#10;                return region;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // Función separada para manejar cambios de región&#10;    private void handleRegionChange(Player player, State state, Region previousRegion, Region currentRegion) {&#10;        if (previousRegion != null) {&#10;            // Guardar el tiempo AFK antes de salir de la región&#10;            if (plugin.statistics().isEnabled()) {&#10;                int secondsInRegion = state.elapsed() / 20;&#10;                if (secondsInRegion &gt; 0) {&#10;                    plugin.statistics().addAFKTime(player.getUniqueId(), player.getName(), secondsInRegion);&#10;                    if (debug) debug(&quot;Saved &quot; + secondsInRegion + &quot; AFK seconds for player &quot; + player.getName());&#10;                }&#10;            }&#10;&#10;            adapter.onExit(player, previousRegion);&#10;            if (resetOnExit) {&#10;                state.elapsed(0);&#10;            }&#10;&#10;            state.firedSeconds().clear();&#10;            player.sendMessage(plugin.messages().msg(&quot;left_region&quot;).replace(&quot;{region}&quot;, previousRegion.name()));&#10;&#10;            if (debug) debug(&quot;Player &quot; + player.getName() + &quot; left region: &quot; + previousRegion.name());&#10;        }&#10;&#10;        state.region(currentRegion);&#10;&#10;        if (currentRegion != null) {&#10;            state.elapsed(0);&#10;            state.firedSeconds().clear();&#10;            adapter.onEnter(player, currentRegion);&#10;            player.sendMessage(plugin.messages().msg(&quot;entered_region&quot;).replace(&quot;{region}&quot;, currentRegion.name()));&#10;&#10;            if (debug) debug(&quot;Player &quot; + player.getName() + &quot; entered region: &quot; + currentRegion.name());&#10;        }&#10;    }&#10;&#10;    // Función renombrada para claridad - solo maneja recompensas y progreso&#10;    private void tickRewards() {&#10;        for (Player player : Bukkit.getOnlinePlayers()) {&#10;            State state = states.get(player.getUniqueId());&#10;            if (state == null || state.region() == null) {&#10;                continue;&#10;            }&#10;&#10;            int totalTicks = state.region().durationSeconds() * 20;&#10;&#10;            int prev = state.elapsed();&#10;            int prevSec = prev / 20;&#10;&#10;            state.elapsed((state.elapsed() + tickInterval) % totalTicks);&#10;            int curr = state.elapsed();&#10;            int currSec = curr / 20;&#10;&#10;            boolean wrapped = curr &lt; prev;&#10;            if (wrapped) {&#10;                state.firedSeconds().clear();&#10;&#10;                adapter.onEnter(player, state.region());&#10;                adapter.updateProgress(player, state.region(), 0, 0.0);&#10;            }&#10;&#10;            if (debug) debug(&quot;tick &quot; + player.getName() + &quot; region=&quot; + state.region().name() +&#10;                    &quot; prev=&quot; + prev + &quot; (&quot; + prevSec + &quot;s) curr=&quot; + curr + &quot; (&quot; + currSec + &quot;s) wrapped=&quot; + wrapped);&#10;&#10;            if (debug) debug(&quot;  rewards=&quot; + state.region().rewards().size());&#10;&#10;            Set&lt;Integer&gt; crossedAts = new LinkedHashSet&lt;&gt;();&#10;            for (RegionReward reward : state.region().rewards()) {&#10;                if (reward.atSeconds() &lt; 0) {&#10;                    continue;&#10;                }&#10;&#10;                boolean crossed;&#10;                if (!wrapped) {&#10;                    crossed = (reward.atSeconds() &gt; prevSec &amp;&amp; reward.atSeconds() &lt;= currSec);&#10;                } else {&#10;                    crossed = (reward.atSeconds() &gt; prevSec) || (reward.atSeconds() &lt;= currSec);&#10;                }&#10;&#10;                if (crossed) {&#10;                    crossedAts.add(reward.atSeconds());&#10;                }&#10;            }&#10;            if (debug) debug(&quot;  crossed=&quot; + crossedAts);&#10;&#10;            for (int atSec : crossedAts) {&#10;                if (state.firedSeconds().contains(atSec)) continue;&#10;&#10;                for (RegionReward reward : state.region().rewards()) {&#10;                    if (reward.atSeconds() == atSec &amp;&amp; reward.roll()) {&#10;                        String cmd = reward.command().replace(&quot;{player}&quot;, player.getName());&#10;&#10;                        if (Bukkit.getPluginManager().isPluginEnabled(&quot;PlaceholderAPI&quot;)) {&#10;                            try {&#10;                                cmd = PlaceholderAPI.setPlaceholders(player, cmd);&#10;                            } catch (Throwable ignored) {&#10;                            }&#10;                        }&#10;&#10;                        Bukkit.dispatchCommand(Bukkit.getConsoleSender(), cmd);&#10;                        if (debug) debug(&quot;  fired at=&quot; + atSec + &quot;s cmd=&quot; + cmd);&#10;                        if (rewardMsgEnabled) {&#10;                            player.sendMessage(plugin.messages().msg(&quot;reward_given&quot;).replace(&quot;{command}&quot;, cmd));&#10;                        }&#10;                    }&#10;                }&#10;&#10;                state.firedSeconds.add(atSec);&#10;            }&#10;&#10;            double progress = Math.max(0.0, Math.min(1.0, (double) currSec / (double) state.region().durationSeconds()));&#10;            adapter.updateProgress(player, state.region(), currSec, progress);&#10;        }&#10;    }&#10;&#10;    // Remover el EventHandler para PlayerMoveEvent ya que ahora usamos una tarea programada&#10;    // @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)&#10;    // public void onMove(PlayerMoveEvent event) { ... }&#10;&#10;    // Función legacy mantenida para compatibilidad, pero ya no se usa internamente&#10;    @Deprecated&#10;    private void onBlockChange(Player player, Location location) {&#10;        // Esta función se mantiene por compatibilidad pero ya no se usa&#10;        // La funcionalidad se movió a checkPlayerRegions()&#10;    }&#10;&#10;    public String placeholder(UUID id, String key) {&#10;        State state = states.get(id);&#10;        if (state == null || state.region() == null) {&#10;            return &quot;&quot;;&#10;        }&#10;        int elapsedSec = state.elapsed() / 20;&#10;&#10;        switch (key) {&#10;            case &quot;region&quot;:&#10;                return state.region().name();&#10;            case &quot;elapsed&quot;:&#10;                return String.valueOf(elapsedSec);&#10;&#10;            case &quot;duration&quot;:&#10;                return String.valueOf(durationSeconds(id));&#10;            case &quot;progress&quot;:&#10;            case &quot;progress_percent&quot;:&#10;                return String.valueOf(progressPercent(id));&#10;            case &quot;progress_bar&quot;:&#10;                return progressBar(id);&#10;            case &quot;time_left&quot;:&#10;                return String.valueOf(timeLeftSeconds(id));&#10;&#10;            default:&#10;                return &quot;&quot;;&#10;        }&#10;    }&#10;&#10;    public void refreshRegionRef(String regionName) {&#10;        for (State state : states.values()) {&#10;            if (state != null &amp;&amp; state.region() != null &amp;&amp; state.region().name().equalsIgnoreCase(regionName)) {&#10;                Region region = plugin.regions().get(regionName);&#10;&#10;                if (region != null) {&#10;                    state.region(region);&#10;                    state.firedSeconds().clear();&#10;                    state.elapsed(0);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public boolean isAfk(UUID id) {&#10;        State state = states.get(id);&#10;&#10;        return state != null &amp;&amp; state.region != null;&#10;    }&#10;&#10;    public String regionName(UUID id) {&#10;        State state = states.get(id);&#10;&#10;        return state != null &amp;&amp; state.region() != null ? state.region().name() : &quot;&quot;;&#10;    }&#10;&#10;    public int elapsedSeconds(UUID id) {&#10;        State state = states.get(id);&#10;&#10;        return state != null &amp;&amp; state.region() != null ? (state.elapsed() / 20) : 0;&#10;    }&#10;&#10;    public int durationSeconds(UUID id) {&#10;        State state = states.get(id);&#10;&#10;        return (state != null &amp;&amp; state.region() != null) ? state.region().durationSeconds() : 0;&#10;    }&#10;&#10;    public int progressPercent(UUID id) {&#10;        int seconds = durationSeconds(id);&#10;        int elapsed = elapsedSeconds(id);&#10;&#10;        if (seconds &lt;= 0) {&#10;            return 0;&#10;        }&#10;&#10;        return (int) Math.round(100.0 * elapsed / seconds);&#10;    }&#10;&#10;    public int timeLeftSeconds(UUID id) {&#10;        int seconds = durationSeconds(id);&#10;        int elapsed = elapsedSeconds(id);&#10;&#10;        if (seconds &lt;= 0) {&#10;            return 0;&#10;        }&#10;&#10;        return Math.max(0, seconds - elapsed);&#10;    }&#10;&#10;    public String progressBar(UUID id) {&#10;        return progressBar(id, 20, '|', '.');&#10;    }&#10;&#10;    public String progressBar(UUID id, int segments, char filled, char empty) {&#10;        int percentage = progressPercent(id);&#10;        int fill = (int) Math.round((segments * percentage) / 100.0);&#10;&#10;        StringBuilder builder = new StringBuilder(segments);&#10;        for (int i = 0; i &lt; segments; i++) {&#10;            builder.append(i &lt; fill ? filled : empty);&#10;        }&#10;&#10;        return builder.toString();&#10;    }&#10;&#10;    private static class State {&#10;        private final Player player;&#10;        private Region region;&#10;        private int elapsed;&#10;&#10;        private final Set&lt;Integer&gt; firedSeconds = new HashSet&lt;&gt;();&#10;&#10;        State(Player player) {&#10;            this.player = player;&#10;            this.region = null;&#10;            this.elapsed = 0;&#10;        }&#10;&#10;        public Player player() {&#10;            return player;&#10;        }&#10;&#10;        public Region region() {&#10;            return region;&#10;        }&#10;&#10;        public void region(Region region) {&#10;            this.region = region;&#10;        }&#10;&#10;        public int elapsed() {&#10;            return elapsed;&#10;        }&#10;&#10;        public void elapsed(int elapsed) {&#10;            this.elapsed = elapsed;&#10;        }&#10;&#10;        public Set&lt;Integer&gt; firedSeconds() {&#10;            return firedSeconds;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package net.mineaqua.afkregions.runtime;&#10;&#10;import me.clip.placeholderapi.PlaceholderAPI;&#10;import net.mineaqua.afkregions.AFKRegionsPlugin;&#10;import net.mineaqua.afkregions.model.Region;&#10;import net.mineaqua.afkregions.model.RegionReward;&#10;import net.mineaqua.afkregions.version.VersionAdapter;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.scheduler.BukkitRunnable;&#10;&#10;import java.util.HashMap;&#10;import java.util.HashSet;&#10;import java.util.LinkedHashSet;&#10;import java.util.Map;&#10;import java.util.Objects;&#10;import java.util.Set;&#10;import java.util.UUID;&#10;&#10;public class PlayerTracker {&#10;    private final Map&lt;UUID, State&gt; states = new HashMap&lt;&gt;();&#10;    private final AFKRegionsPlugin plugin;&#10;    private final VersionAdapter adapter;&#10;&#10;    private int tickInterval;&#10;    private int regionCheckInterval; // Nueva variable para el intervalo de verificación de regiones&#10;    private int rewardTaskId = -1;&#10;    private int regionCheckTaskId = -1; // Nueva tarea para verificar regiones&#10;&#10;    private boolean resetOnExit;&#10;    private boolean debug;&#10;    private boolean rewardMsgEnabled;&#10;&#10;    private void debug(String text) {&#10;        if (debug) plugin.getLogger().info(&quot;[DEBUG] &quot; + text);&#10;    }&#10;&#10;    public PlayerTracker(AFKRegionsPlugin plugin) {&#10;        this.plugin = plugin;&#10;        this.adapter = plugin.adapter();&#10;&#10;        reloadSettings();&#10;&#10;        this.debug = plugin.getConfig().getBoolean(&quot;settings.debug&quot;, false);&#10;    }&#10;&#10;    public void reloadSettings() {&#10;        this.tickInterval = Math.max(1, plugin.getConfig().getInt(&quot;settings.tick_interval&quot;, 20));&#10;        // Nuevo: intervalo para verificar regiones (por defecto cada 10 ticks = 0.5 segundos)&#10;        this.regionCheckInterval = Math.max(1, plugin.getConfig().getInt(&quot;settings.region_check_interval&quot;, 10));&#10;        this.resetOnExit = plugin.getConfig().getBoolean(&quot;settings.reset_on_exit&quot;, true);&#10;        this.rewardMsgEnabled = plugin.getConfig().getBoolean(&quot;settings.reward_message_enabled&quot;, true);&#10;    }&#10;&#10;    public void start() {&#10;        if (rewardTaskId != -1 || regionCheckTaskId != -1) return;&#10;&#10;        // Tarea para manejar recompensas y progreso&#10;        rewardTaskId = new BukkitRunnable() {&#10;            @Override&#10;            public void run() {&#10;                tickRewards();&#10;            }&#10;        }.runTaskTimer(plugin, tickInterval, tickInterval).getTaskId();&#10;&#10;        // Nueva tarea optimizada para verificar regiones&#10;        regionCheckTaskId = new BukkitRunnable() {&#10;            @Override&#10;            public void run() {&#10;                checkPlayerRegions();&#10;            }&#10;        }.runTaskTimer(plugin, regionCheckInterval, regionCheckInterval).getTaskId();&#10;    }&#10;&#10;    public void stop() {&#10;        if (rewardTaskId != -1) {&#10;            Bukkit.getScheduler().cancelTask(rewardTaskId);&#10;            rewardTaskId = -1;&#10;        }&#10;&#10;        if (regionCheckTaskId != -1) {&#10;            Bukkit.getScheduler().cancelTask(regionCheckTaskId);&#10;            regionCheckTaskId = -1;&#10;        }&#10;&#10;        for (State state : states.values()) {&#10;            adapter.clearUI(state.player());&#10;        }&#10;        states.clear();&#10;    }&#10;&#10;    // Nueva función optimizada para verificar regiones de todos los jugadores&#10;    private void checkPlayerRegions() {&#10;        for (Player player : Bukkit.getOnlinePlayers()) {&#10;            if (!player.isOnline()) continue;&#10;&#10;            Region currentRegion = findRegionAt(player);&#10;&#10;            State state = states.computeIfAbsent(player.getUniqueId(), k -&gt; new State(player));&#10;            Region previousRegion = state.region();&#10;&#10;            if (!Objects.equals(previousRegion, currentRegion)) {&#10;                handleRegionChange(player, state, previousRegion, currentRegion);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Función optimizada para encontrar una región en una posición específica&#10;    private Region findRegionAt(Player player) {&#10;        for (Region region : plugin.regions().candidates(player.getWorld().getName(), player.getLocation().getBlockX(), player.getLocation().getBlockZ())) {&#10;            if (region.contains(player.getWorld().getName(), player.getLocation().getBlockX(), player.getLocation().getBlockY(), player.getLocation().getBlockZ())) {&#10;                return region;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // Función separada para manejar cambios de región&#10;    private void handleRegionChange(Player player, State state, Region previousRegion, Region currentRegion) {&#10;        if (previousRegion != null) {&#10;            // Guardar el tiempo AFK antes de salir de la región&#10;            if (plugin.statistics().isEnabled()) {&#10;                int secondsInRegion = state.elapsed() / 20;&#10;                if (secondsInRegion &gt; 0) {&#10;                    plugin.statistics().addAFKTime(player.getUniqueId(), player.getName(), secondsInRegion);&#10;                    if (debug) debug(&quot;Saved &quot; + secondsInRegion + &quot; AFK seconds for player &quot; + player.getName());&#10;                }&#10;            }&#10;&#10;            adapter.onExit(player, previousRegion);&#10;            if (resetOnExit) {&#10;                state.elapsed(0);&#10;            }&#10;&#10;            state.firedSeconds().clear();&#10;            player.sendMessage(plugin.messages().msg(&quot;left_region&quot;).replace(&quot;{region}&quot;, previousRegion.name()));&#10;&#10;            if (debug) debug(&quot;Player &quot; + player.getName() + &quot; left region: &quot; + previousRegion.name());&#10;        }&#10;&#10;        state.region(currentRegion);&#10;&#10;        if (currentRegion != null) {&#10;            state.elapsed(0);&#10;            state.firedSeconds().clear();&#10;            adapter.onEnter(player, currentRegion);&#10;            player.sendMessage(plugin.messages().msg(&quot;entered_region&quot;).replace(&quot;{region}&quot;, currentRegion.name()));&#10;&#10;            if (debug) debug(&quot;Player &quot; + player.getName() + &quot; entered region: &quot; + currentRegion.name());&#10;        }&#10;    }&#10;&#10;    // Función renombrada para claridad - solo maneja recompensas y progreso&#10;    private void tickRewards() {&#10;        for (Player player : Bukkit.getOnlinePlayers()) {&#10;            State state = states.get(player.getUniqueId());&#10;            if (state == null || state.region() == null) {&#10;                continue;&#10;            }&#10;&#10;            int totalTicks = state.region().durationSeconds() * 20;&#10;&#10;            int prev = state.elapsed();&#10;            int prevSec = prev / 20;&#10;&#10;            state.elapsed((state.elapsed() + tickInterval) % totalTicks);&#10;            int curr = state.elapsed();&#10;            int currSec = curr / 20;&#10;&#10;            boolean wrapped = curr &lt; prev;&#10;            if (wrapped) {&#10;                state.firedSeconds().clear();&#10;&#10;                adapter.onEnter(player, state.region());&#10;                adapter.updateProgress(player, state.region(), 0, 0.0);&#10;            }&#10;&#10;            if (debug) debug(&quot;tick &quot; + player.getName() + &quot; region=&quot; + state.region().name() +&#10;                    &quot; prev=&quot; + prev + &quot; (&quot; + prevSec + &quot;s) curr=&quot; + curr + &quot; (&quot; + currSec + &quot;s) wrapped=&quot; + wrapped);&#10;&#10;            if (debug) debug(&quot;  rewards=&quot; + state.region().rewards().size());&#10;&#10;            Set&lt;Integer&gt; crossedAts = new LinkedHashSet&lt;&gt;();&#10;            for (RegionReward reward : state.region().rewards()) {&#10;                if (reward.atSeconds() &lt; 0) {&#10;                    continue;&#10;                }&#10;&#10;                boolean crossed;&#10;                if (!wrapped) {&#10;                    crossed = (reward.atSeconds() &gt; prevSec &amp;&amp; reward.atSeconds() &lt;= currSec);&#10;                } else {&#10;                    crossed = (reward.atSeconds() &gt; prevSec) || (reward.atSeconds() &lt;= currSec);&#10;                }&#10;&#10;                if (crossed) {&#10;                    crossedAts.add(reward.atSeconds());&#10;                }&#10;            }&#10;            if (debug) debug(&quot;  crossed=&quot; + crossedAts);&#10;&#10;            for (int atSec : crossedAts) {&#10;                if (state.firedSeconds().contains(atSec)) continue;&#10;&#10;                for (RegionReward reward : state.region().rewards()) {&#10;                    if (reward.atSeconds() == atSec &amp;&amp; reward.roll()) {&#10;                        String cmd = reward.command().replace(&quot;{player}&quot;, player.getName());&#10;&#10;                        if (Bukkit.getPluginManager().isPluginEnabled(&quot;PlaceholderAPI&quot;)) {&#10;                            try {&#10;                                cmd = PlaceholderAPI.setPlaceholders(player, cmd);&#10;                            } catch (Throwable ignored) {&#10;                            }&#10;                        }&#10;&#10;                        Bukkit.dispatchCommand(Bukkit.getConsoleSender(), cmd);&#10;                        if (debug) debug(&quot;  fired at=&quot; + atSec + &quot;s cmd=&quot; + cmd);&#10;                        if (rewardMsgEnabled) {&#10;                            player.sendMessage(plugin.messages().msg(&quot;reward_given&quot;).replace(&quot;{command}&quot;, cmd));&#10;                        }&#10;                    }&#10;                }&#10;&#10;                state.firedSeconds.add(atSec);&#10;            }&#10;&#10;            double progress = Math.max(0.0, Math.min(1.0, (double) currSec / (double) state.region().durationSeconds()));&#10;            adapter.updateProgress(player, state.region(), currSec, progress);&#10;        }&#10;    }&#10;&#10;    // Remover el EventHandler para PlayerMoveEvent ya que ahora usamos una tarea programada&#10;    // @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)&#10;    // public void onMove(PlayerMoveEvent event) { ... }&#10;&#10;    public void refreshRegionRef(String regionName) {&#10;        for (State state : states.values()) {&#10;            if (state != null &amp;&amp; state.region() != null &amp;&amp; state.region().name().equalsIgnoreCase(regionName)) {&#10;                Region region = plugin.regions().get(regionName);&#10;&#10;                if (region != null) {&#10;                    state.region(region);&#10;                    state.firedSeconds().clear();&#10;                    state.elapsed(0);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public boolean isAfk(UUID id) {&#10;        State state = states.get(id);&#10;&#10;        return state != null &amp;&amp; state.region != null;&#10;    }&#10;&#10;    public String regionName(UUID id) {&#10;        State state = states.get(id);&#10;&#10;        return state != null &amp;&amp; state.region() != null ? state.region().name() : &quot;&quot;;&#10;    }&#10;&#10;    public int elapsedSeconds(UUID id) {&#10;        State state = states.get(id);&#10;&#10;        return state != null &amp;&amp; state.region() != null ? (state.elapsed() / 20) : 0;&#10;    }&#10;&#10;    public int durationSeconds(UUID id) {&#10;        State state = states.get(id);&#10;&#10;        return (state != null &amp;&amp; state.region() != null) ? state.region().durationSeconds() : 0;&#10;    }&#10;&#10;    public int progressPercent(UUID id) {&#10;        int seconds = durationSeconds(id);&#10;        int elapsed = elapsedSeconds(id);&#10;&#10;        if (seconds &lt;= 0) {&#10;            return 0;&#10;        }&#10;&#10;        return (int) Math.round(100.0 * elapsed / seconds);&#10;    }&#10;&#10;    public int timeLeftSeconds(UUID id) {&#10;        int seconds = durationSeconds(id);&#10;        int elapsed = elapsedSeconds(id);&#10;&#10;        if (seconds &lt;= 0) {&#10;            return 0;&#10;        }&#10;&#10;        return Math.max(0, seconds - elapsed);&#10;    }&#10;&#10;    public String progressBar(UUID id) {&#10;        return progressBar(id, 20, '|', '.');&#10;    }&#10;&#10;    public String progressBar(UUID id, int segments, char filled, char empty) {&#10;        int percentage = progressPercent(id);&#10;        int fill = (int) Math.round((segments * percentage) / 100.0);&#10;&#10;        StringBuilder builder = new StringBuilder(segments);&#10;        for (int i = 0; i &lt; segments; i++) {&#10;            builder.append(i &lt; fill ? filled : empty);&#10;        }&#10;&#10;        return builder.toString();&#10;    }&#10;&#10;    private static class State {&#10;        private final Player player;&#10;        private Region region;&#10;        private int elapsed;&#10;&#10;        private final Set&lt;Integer&gt; firedSeconds = new HashSet&lt;&gt;();&#10;&#10;        State(Player player) {&#10;            this.player = player;&#10;            this.region = null;&#10;            this.elapsed = 0;&#10;        }&#10;&#10;        public Player player() {&#10;            return player;&#10;        }&#10;&#10;        public Region region() {&#10;            return region;&#10;        }&#10;&#10;        public void region(Region region) {&#10;            this.region = region;&#10;        }&#10;&#10;        public int elapsed() {&#10;            return elapsed;&#10;        }&#10;&#10;        public void elapsed(int elapsed) {&#10;            this.elapsed = elapsed;&#10;        }&#10;&#10;        public Set&lt;Integer&gt; firedSeconds() {&#10;            return firedSeconds;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/config.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/config.yml" />
              <option name="originalContent" value="settings:&#10;  debug: false&#10;  titles_enabled: true&#10;  titles_enter_exit: true    # Set false to disable the titles on entry/exit afk region&#10;  title_every_seconds: 1      # Every how much seconds the title will be refreshed. recommended: 1&#10;  reset_on_exit: true # Reset timer on exit of the afk region&#10;  tick_interval: 20 # The update in ticks, 20 = 1s&#10;  region_check_interval: 10 # The interval in ticks to check player regions, 10 = 0.5s (NEW OPTIMIZED SETTING)&#10;  bossbar_enabled: true # Enable or disable the bossbar. +1.9 feature true/false&#10;  bossbar_title: &quot;&amp;bAFK &amp;7in &amp;f{region}&amp;7 — &amp;b{elapsed}&amp;7/&amp;f{max} &amp;7({progress%}%)&quot;&#10;  bossbar_color: &quot;BLUE&quot;   # BLUE, GREEN, PINK, PURPLE, RED, WHITE, YELLOW&#10;  bossbar_style: &quot;SEGMENTED_10&quot; # Normally I do not recommend modifying this&#10;  reward_message_enabled: true # Send the reward message on player reward true/false&#10;&#10;# Database configuration for storing AFK statistics&#10;database:&#10;  enabled: false # Set to true to enable database storage&#10;  host: &quot;localhost&quot;&#10;  port: 3306&#10;  database: &quot;afkregions&quot;&#10;  username: &quot;root&quot;&#10;  password: &quot;&quot;&#10;  use_ssl: false&#10;&#10;# Statistics system configuration&#10;statistics:&#10;  enabled: true # Set to false to completely disable statistics tracking&#10;  auto_save_interval_minutes: 5 # How often to save statistics to database (in minutes)" />
              <option name="updatedContent" value="settings:&#10;  debug: false&#10;  titles_enabled: true&#10;  titles_enter_exit: true    # Set false to disable the titles on entry/exit afk region&#10;  title_every_seconds: 1      # Every how much seconds the title will be refreshed. recommended: 1&#10;  reset_on_exit: true # Reset timer on exit of the afk region&#10;  tick_interval: 20 # The update in ticks, 20 = 1s&#10;  region_check_interval: 10 # The interval in ticks to check player regions, 10 = 0.5s (NEW OPTIMIZED SETTING)&#10;  bossbar_enabled: true # Enable or disable the bossbar. +1.9 feature true/false&#10;  bossbar_title: &quot;&amp;bAFK &amp;7in &amp;f{region}&amp;7 — &amp;b{elapsed}&amp;7/&amp;f{max} &amp;7({progress%}%)&quot;&#10;  bossbar_color: &quot;BLUE&quot;   # BLUE, GREEN, PINK, PURPLE, RED, WHITE, YELLOW&#10;  bossbar_style: &quot;SEGMENTED_10&quot; # Normally I do not recommend modifying this&#10;  reward_message_enabled: true # Send the reward message on player reward true/false&#10;&#10;# Database configuration for storing AFK statistics&#10;database:&#10;  enabled: false # Set to true to enable database storage&#10;  host: &quot;localhost&quot;&#10;  port: 3306&#10;  database: &quot;afkregions&quot;&#10;  username: &quot;root&quot;&#10;  password: &quot;&quot;&#10;  use_ssl: false&#10;&#10;# Statistics system configuration&#10;statistics:&#10;  enabled: true # Set to false to completely disable statistics tracking&#10;  auto_save_interval_minutes: 5 # How often to save statistics to database (in minutes)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/lang.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/lang.yml" />
              <option name="originalContent" value="# ────────────────&#10;# General&#10;# ────────────────&#10;prefix: &quot;&amp;8[&amp;bAFK&amp;7Regions&amp;8]&amp;r &quot;&#10;no_perm: &quot;&amp;cYou don't have permission.&quot;&#10;invalid_args: &quot;&amp;cInvalid arguments. Use &amp;e/afkregions help&quot;&#10;region_not_found: &quot;&amp;cRegion &amp;f{region}&amp;c does not exist.&quot;&#10;reloaded: &quot;&amp;aConfiguration reloaded.&quot;&#10;&#10;# ────────────────&#10;# Region Management&#10;# ────────────────&#10;created_region: &quot;&amp;aRegion &amp;f{region}&amp;a successfully created.&quot;&#10;removed_region: &quot;&amp;cRegion &amp;f{region}&amp;c removed.&quot;&#10;list_header: &quot;&amp;7Regions (&amp;f{count}&amp;7):&quot;&#10;list_item: &quot; &amp;8- &amp;f{name}&amp;7 @ &amp;f{world}&amp;7 [{min} → {max}] &amp;7/ &amp;f{duration}s &amp;7/ rewards: &amp;f{rewards}&quot;&#10;&#10;# ────────────────&#10;# Enter/Exit Events&#10;# ────────────────&#10;entered_region: &quot;&amp;7You have entered the region &amp;f{region}&amp;7.&quot;&#10;left_region: &quot;&amp;7You have left the region &amp;f{region}&amp;7.&quot;&#10;enter_title:&#10;  title: &quot;&amp;bAFK started&quot;&#10;  subtitle: &quot;&amp;7Region &amp;f{region}&quot;&#10;  fadeIn: 5&#10;  stay: 30&#10;  fadeOut: 10&#10;exit_title:&#10;  title: &quot;&amp;cAFK stopped&quot;&#10;  subtitle: &quot;&amp;7You have left &amp;f{region}&quot;&#10;  fadeIn: 5&#10;  stay: 30&#10;  fadeOut: 10&#10;&#10;# ────────────────&#10;# Rewards&#10;# ────────────────&#10;added_reward: &quot;&amp;aReward added to &amp;f{region}&amp;a: &amp;e{spec}&quot;&#10;reward_given: &quot;&amp;aYou have received a reward! &amp;7({command})&quot;&#10;&#10;# ────────────────&#10;# Progress&#10;# ────────────────&#10;progress_title:&#10;  title: &quot;&amp;bAFK &amp;7{elapsed}/{max}&quot;&#10;  subtitle: &quot;&amp;7Region &amp;f{region}&amp;7 — &amp;f{progress%}%&quot;&#10;&#10;# ────────────────&#10;# Help&#10;# ────────────────&#10;help_wand: &quot;&amp;b/afkregions wand &amp;7– Select region (left=pos1, right=pos2)&quot;&#10;help_create: &quot;&amp;b/afkregions create &lt;name&gt; &lt;duration_s&gt; &amp;7– Create region from selection&quot;&#10;help_reward_list: &quot;&amp;b/afkregions reward list &lt;region&gt;&quot;&#10;help_reward_add: &quot;&amp;b/afkregions reward add &lt;region&gt; &lt;percent%&gt; &lt;time_s&gt; &lt;command...&gt;&quot;&#10;help_reward_remove: &quot;&amp;b/afkregions reward remove &lt;region&gt; &lt;index&gt;&quot;&#10;help_reload: &quot;&amp;b/afkregions reload&quot;&#10;&#10;# ────────────────&#10;# Wand / Selection&#10;# ────────────────&#10;wand_only_players: &quot;&amp;cOnly players can use this command.&quot;&#10;wand_given: &quot;&amp;aWand given. &amp;7Left click = Pos1, right click = Pos2.&quot;&#10;selection_needed: &quot;&amp;cYou must select Pos1 and Pos2 with &amp;e/{label} wand&amp;c.&quot;&#10;selection_world_mismatch: &quot;&amp;cPos1 and Pos2 must be in the same world as you.&quot;&#10;&#10;# ────────────────&#10;# Reward (command)&#10;# ────────────────&#10;reward_usage_main: &quot;&amp;eUsage: /afkregions reward &lt;list|add|remove&gt; ...&quot;&#10;reward_list_usage: &quot;&amp;cUsage: /afkregions reward list &lt;region&gt;&quot;&#10;reward_add_usage: &quot;&amp;cUsage: /afkregions reward add &lt;region&gt; &lt;percent%&gt; &lt;time_s&gt; &lt;command...&gt;&quot;&#10;reward_remove_usage: &quot;&amp;cUsage: /afkregions reward remove &lt;region&gt; &lt;index&gt;&quot;&#10;percentage_end_percent: &quot;&amp;cThe percentage must end with % (e.g.: 100%).&quot;&#10;percentage_invalid: &quot;&amp;cInvalid percentage.&quot;&#10;time_end_s: &quot;&amp;cTime must end with 's' (seconds), e.g.: 10s.&quot;&#10;time_invalid: &quot;&amp;cInvalid time.&quot;&#10;time_must_be_ge_zero: &quot;&amp;cTime must be greater than or equal to 0 seconds.&quot;&#10;index_invalid: &quot;&amp;cInvalid index.&quot;&#10;index_oob: &quot;&amp;cOut of range. Use &amp;e/afkregions reward list {region}&quot;&#10;rewards_header: &quot;&amp;aRewards in &amp;e{region}&amp;a:&quot;&#10;rewards_item: &quot; &amp;8{index}) &amp;7at=&amp;f{at} &amp;7chance=&amp;e{chance}% &amp;7cmd=&amp;f{command}&quot;&#10;removed_reward: &quot;&amp;aRemoved reward &amp;8#{index} &amp;7(at=&amp;f{at}&amp;7, chance=&amp;e{chance}%&amp;7).&quot;&#10;subcommand_invalid: &quot;&amp;cInvalid subcommand. Use: list, add, remove.&quot;&#10;" />
              <option name="updatedContent" value="# ────────────────&#10;# General&#10;# ────────────────&#10;prefix: &quot;&amp;8[&amp;bAFK&amp;7Regions&amp;8]&amp;r &quot;&#10;no_perm: &quot;&amp;cYou don't have permission.&quot;&#10;invalid_args: &quot;&amp;cInvalid arguments. Use &amp;e/afkregions help&quot;&#10;region_not_found: &quot;&amp;cRegion &amp;f{region}&amp;c does not exist.&quot;&#10;reloaded: &quot;&amp;aConfiguration reloaded.&quot;&#10;&#10;# ────────────────&#10;# Region Management&#10;# ────────────────&#10;created_region: &quot;&amp;aRegion &amp;f{region}&amp;a successfully created.&quot;&#10;removed_region: &quot;&amp;cRegion &amp;f{region}&amp;c removed.&quot;&#10;list_header: &quot;&amp;7Regions (&amp;f{count}&amp;7):&quot;&#10;list_item: &quot; &amp;8- &amp;f{name}&amp;7 @ &amp;f{world}&amp;7 [{min} → {max}] &amp;7/ &amp;f{duration}s &amp;7/ rewards: &amp;f{rewards}&quot;&#10;&#10;# ────────────────&#10;# Enter/Exit Events&#10;# ────────────────&#10;entered_region: &quot;&amp;7You have entered the region &amp;f{region}&amp;7.&quot;&#10;left_region: &quot;&amp;7You have left the region &amp;f{region}&amp;7.&quot;&#10;enter_title:&#10;  title: &quot;&amp;bAFK started&quot;&#10;  subtitle: &quot;&amp;7Region &amp;f{region}&quot;&#10;  fadeIn: 5&#10;  stay: 30&#10;  fadeOut: 10&#10;exit_title:&#10;  title: &quot;&amp;cAFK stopped&quot;&#10;  subtitle: &quot;&amp;7You have left &amp;f{region}&quot;&#10;  fadeIn: 5&#10;  stay: 30&#10;  fadeOut: 10&#10;&#10;# ────────────────&#10;# Rewards&#10;# ────────────────&#10;added_reward: &quot;&amp;aReward added to &amp;f{region}&amp;a: &amp;e{spec}&quot;&#10;reward_given: &quot;&amp;aYou have received a reward! &amp;7({command})&quot;&#10;&#10;# ────────────────&#10;# Progress&#10;# ────────────────&#10;progress_title:&#10;  title: &quot;&amp;bAFK &amp;7{elapsed}/{max}&quot;&#10;  subtitle: &quot;&amp;7Region &amp;f{region}&amp;7 — &amp;f{progress%}%&quot;&#10;&#10;# ────────────────&#10;# Help&#10;# ────────────────&#10;help_wand: &quot;&amp;e/afkregions wand &amp;7- Get the region selection wand&quot;&#10;help_create: &quot;&amp;e/afkregions create &lt;name&gt; &lt;duration_seconds&gt; &amp;7- Create a new AFK region&quot;&#10;help_reward_list: &quot;&amp;e/afkregions reward list &lt;region&gt; &amp;7- List rewards for a region&quot;&#10;help_reward_add: &quot;&amp;e/afkregions reward add &lt;region&gt; &lt;chance%&gt; &lt;time_s&gt; &lt;command&gt; &amp;7- Add a reward&quot;&#10;help_reward_remove: &quot;&amp;e/afkregions reward remove &lt;region&gt; &lt;index&gt; &amp;7- Remove a reward&quot;&#10;help_reload: &quot;&amp;e/afkregions reload &amp;7- Reload the plugin configuration&quot;&#10;help_stats: &quot;&amp;e/afkregions stats &lt;player|save|info&gt; &amp;7- View statistics or manage system&quot;&#10;&#10;# ────────────────&#10;# Wand / Selection&#10;# ────────────────&#10;wand_only_players: &quot;&amp;cOnly players can use this command.&quot;&#10;wand_given: &quot;&amp;aWand given. &amp;7Left click = Pos1, right click = Pos2.&quot;&#10;selection_needed: &quot;&amp;cYou must select Pos1 and Pos2 with &amp;e/{label} wand&amp;c.&quot;&#10;selection_world_mismatch: &quot;&amp;cPos1 and Pos2 must be in the same world as you.&quot;&#10;&#10;# ────────────────&#10;# Reward (command)&#10;# ────────────────&#10;reward_usage_main: &quot;&amp;eUsage: /afkregions reward &lt;list|add|remove&gt; ...&quot;&#10;reward_list_usage: &quot;&amp;cUsage: /afkregions reward list &lt;region&gt;&quot;&#10;reward_add_usage: &quot;&amp;cUsage: /afkregions reward add &lt;region&gt; &lt;percent%&gt; &lt;time_s&gt; &lt;command...&gt;&quot;&#10;reward_remove_usage: &quot;&amp;cUsage: /afkregions reward remove &lt;region&gt; &lt;index&gt;&quot;&#10;percentage_end_percent: &quot;&amp;cThe percentage must end with % (e.g.: 100%).&quot;&#10;percentage_invalid: &quot;&amp;cInvalid percentage.&quot;&#10;time_end_s: &quot;&amp;cTime must end with 's' (seconds), e.g.: 10s.&quot;&#10;time_invalid: &quot;&amp;cInvalid time.&quot;&#10;time_must_be_ge_zero: &quot;&amp;cTime must be greater than or equal to 0 seconds.&quot;&#10;index_invalid: &quot;&amp;cInvalid index.&quot;&#10;index_oob: &quot;&amp;cOut of range. Use &amp;e/afkregions reward list {region}&quot;&#10;rewards_header: &quot;&amp;aRewards in &amp;e{region}&amp;a:&quot;&#10;rewards_item: &quot; &amp;8{index}) &amp;7at=&amp;f{at} &amp;7chance=&amp;e{chance}% &amp;7cmd=&amp;f{command}&quot;&#10;removed_reward: &quot;&amp;aRemoved reward &amp;8#{index} &amp;7(at=&amp;f{at}&amp;7, chance=&amp;e{chance}%&amp;7).&quot;&#10;subcommand_invalid: &quot;&amp;cInvalid subcommand. Use: list, add, remove.&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>